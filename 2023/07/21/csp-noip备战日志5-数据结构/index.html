<!DOCTYPE html><html lang="zh_CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>csp-noip备战日志5-数据结构 | 溢光亭</title><meta name="author" content="rockeyleo"><meta name="copyright" content="rockeyleo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="五 数据结构1 队列 1. 队列的基本应用 e.g. [P2827] [NOIP2016] 蚯蚓 ps.本题的洛谷数据和xcoj数据或不甚相同 *这是一道历经重重波折的题目…… 简单通读题目，虽然参数有点小多，但是题意还是比较清晰的 不难发现每个蚯蚓的增长率是相同的，它们类似于一条条增长率相同的直线，在每一个时刻，它们的相对关系不会变化。  如上图所示，每一条线就代表一条蚯蚓，">
<meta property="og:type" content="article">
<meta property="og:title" content="csp-noip备战日志5-数据结构">
<meta property="og:url" content="https://rockeyleo.github.io/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%975-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="溢光亭">
<meta property="og:description" content="五 数据结构1 队列 1. 队列的基本应用 e.g. [P2827] [NOIP2016] 蚯蚓 ps.本题的洛谷数据和xcoj数据或不甚相同 *这是一道历经重重波折的题目…… 简单通读题目，虽然参数有点小多，但是题意还是比较清晰的 不难发现每个蚯蚓的增长率是相同的，它们类似于一条条增长率相同的直线，在每一个时刻，它们的相对关系不会变化。  如上图所示，每一条线就代表一条蚯蚓，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-07-21T13:25:43.000Z">
<meta property="article:modified_time" content="2025-02-19T17:33:12.163Z">
<meta property="article:author" content="rockeyleo">
<meta property="article:tag" content="学习手记">
<meta property="article:tag" content="csp-noip备战日志">
<meta property="article:tag" content="OI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://rockeyleo.github.io/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%975-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'csp-noip备战日志5-数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-20 01:33:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/my.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/07/22/PFz9shrI5nGAZmx.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="溢光亭"><span class="site-name">溢光亭</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">csp-noip备战日志5-数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-07-21T13:25:43.000Z" title="Created 2023-07-21 21:25:43">2023-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-02-19T17:33:12.163Z" title="Updated 2025-02-20 01:33:12">2025-02-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="csp-noip备战日志5-数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="五-数据结构1">五 数据结构<a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a></h1>
<h2 id="队列">队列</h2>
<h3 id="队列的基本应用">1. 队列的基本应用</h3>
<h6 id="e.g.-p2827-noip2016-蚯蚓">e.g. <a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2827">[P2827] [NOIP2016]
蚯蚓</a></h6>
<p><em>ps.本题的洛谷数据和xcoj数据或不甚相同</em></p>
<p><em>*这是一道历经重重波折的题目……</em></p>
<p>简单通读题目，虽然参数有点小多，但是题意还是比较清晰的</p>
<p>不难发现每个蚯蚓的增长率是相同的，它们类似于一条条增长率相同的直线，在每一个时刻，它们的相对关系不会变化。</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/rr8lyubm.png" /></p>
<p>如上图所示，每一条线就代表一条蚯蚓，当一条蚯蚓被切断时，可以认为原函数消失，并生成了两条新的函数（如红线所示）。这两条函数在t=0时其实并未出现，但我们还是可以用数学方法求出一个截距来。可以证明，被切的蚯蚓在其真正出现之前不会被选中为被切的对象。</p>
<p>那么，我们怎么维护这种大小关系呢？</p>
<p>第一个想法是用单调队列，不断地将选中蚯蚓出队，再加上两个新蚯蚓的长度。这样做的时间复杂度约为<span
class="math inline">\(O(mlogn)\)</span>，您将获得80分的好成绩。</p>
<p>再观察数据的特点，可以发现对于每一时刻被切的<span
class="math inline">\(l_i\)</span>，都会产生<span
class="math inline">\(l_{i_1}=lp\)</span>和<span
class="math inline">\(l_{i_2}=l_i-lp\)</span>两条蚯蚓。因为先被切的蚯蚓<span
class="math inline">\(l_i\)</span>肯定比后切<span
class="math inline">\(l_{i+n}\)</span>长，且先切的蚯蚓产生的<span
class="math inline">\(l_{i_1}与l_{i_2}\)</span>比后切的蚯蚓产生的<span
class="math inline">\(l_{i+n_1}\)</span>与<span
class="math inline">\(l_{i+n_2}\)</span>多生长了<span
class="math inline">\(nq\)</span>的长度，所以在<span
class="math inline">\(p\)</span>一定的情况下，先切出的蚯蚓必然比后切出的在同一时刻更长（这一点同样可以在函数图像中得到验证）。这样，我们直接用两个队列来分别维护<span
class="math inline">\(l_{i_1}\)</span>与<span
class="math inline">\(l_{i_2}\)</span>，队列的内部会是有序的。再用一个队列维护<span
class="math inline">\(l_i\)</span>（当然读入之后需要排个序），每一时刻比较三个队头的大小即可。</p>
<p>这样，我们就得到了一个<span
class="math inline">\(O(m)\)</span>的算法，您可以通过此题。</p>
<p>所以，其实我们只要维护每条函数与y轴的交点之间的大小关系，就能知道所有蚯蚓在任意时刻的关系，并且容易证明，</p>
<p>除此以外，本题还有一些其它注意事项和技巧：</p>
<ul>
<li><p>如果要用一个确定的值来初始化用于存储三个队列头的最大数值的变量，不要用0，而是一个很小的负数</p></li>
<li><p>如果您使用STL的queue，依然可以用<code>queue&lt;int&gt;qu[3]</code>的方式定义一个queue数组，来方便使用诸如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!qu[i].<span class="built_in">empty</span>())&#123;res = qu[i].<span class="built_in">front</span>();<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的方式寻找三个队列中的最大值。</p></li>
<li><p>请务必在计算<span
class="math inline">\(p\)</span>时使用强制类型转换（<span
class="math inline">\(u\)</span>和<span
class="math inline">\(v\)</span>都是int类型，默认进行的是整除计算）</p></li>
</ul>
<p>接下来是喜闻乐见的蒟蒻代码时间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> len[<span class="number">7000010</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; qu[<span class="number">4</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line"><span class="type">int</span> n,m,q,u,v,t,res,flag;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q&gt;&gt;u&gt;&gt;v&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;len[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> p = (<span class="type">double</span>)u/v;         <span class="comment">//如果您省略强制类型转换，将会得到15分的好成绩</span></span><br><span class="line">    <span class="built_in">sort</span>(len+<span class="number">1</span>,len+n+<span class="number">1</span>,[](<span class="type">int</span> a,<span class="type">int</span> b)&#123;<span class="keyword">return</span> a&gt;b;&#125;);</span><br><span class="line">    <span class="comment">//如果您的sort右界忘记+1，将会得到40分的好成绩</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)qu[<span class="number">1</span>].<span class="built_in">push</span>(len[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!qu[i].<span class="built_in">empty</span>())&#123;res = qu[i].<span class="built_in">front</span>();<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="comment">//不建议使用一个固定最小值来初始化res，当然更不能是0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!qu[i].<span class="built_in">empty</span>() <span class="keyword">and</span> qu[i].<span class="built_in">front</span>()&gt;=res)&#123;</span><br><span class="line">                res = qu[i].<span class="built_in">front</span>();</span><br><span class="line">                flag = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        qu[flag].<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(i%t==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res+(i<span class="number">-1</span>)*q);</span><br><span class="line">        <span class="type">int</span> base = (res+(i<span class="number">-1</span>)*q)*p;</span><br><span class="line">        <span class="type">int</span> base2 = (res+(i<span class="number">-1</span>)*q)-base;</span><br><span class="line">        qu[<span class="number">2</span>].<span class="built_in">push</span>(base-i*q);qu[<span class="number">3</span>].<span class="built_in">push</span>(base2-i*q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(!qu[<span class="number">1</span>].<span class="built_in">empty</span>())&#123;ans.<span class="built_in">push_back</span>(qu[<span class="number">1</span>].<span class="built_in">front</span>());qu[<span class="number">1</span>].<span class="built_in">pop</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(!qu[<span class="number">2</span>].<span class="built_in">empty</span>())&#123;ans.<span class="built_in">push_back</span>(qu[<span class="number">2</span>].<span class="built_in">front</span>());qu[<span class="number">2</span>].<span class="built_in">pop</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(!qu[<span class="number">3</span>].<span class="built_in">empty</span>())&#123;ans.<span class="built_in">push_back</span>(qu[<span class="number">3</span>].<span class="built_in">front</span>());qu[<span class="number">3</span>].<span class="built_in">pop</span>();&#125;</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>(),[](<span class="type">int</span> a,<span class="type">int</span> b)&#123;<span class="keyword">return</span> a&gt;b;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=ans.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((i+<span class="number">1</span>)%t==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]+m*q);</span><br><span class="line">        <span class="comment">//千万注意i是从0开始的，与t取模前要加+1（之所以非得0开始是因为ans是个vector，当然您也可以提前压一个数来解决这个问题）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对蚯蚓长度的处理的写法还有另外一种：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="comment">//求res略</span></span><br><span class="line">	res+=dt;</span><br><span class="line">	<span class="type">int</span> base = <span class="built_in">floor</span>((<span class="type">double</span>)res*p);</span><br><span class="line">	<span class="type">int</span> base2 = res-base;</span><br><span class="line">	dt+=q;</span><br><span class="line">	qu[<span class="number">2</span>].<span class="built_in">push</span>(base-dt);</span><br><span class="line">	qu[<span class="number">3</span>].<span class="built_in">push</span>(base2-dt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——一些闲话</p>
<p>为什么说这是一道充满波折的题目呢？<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/discuss/502323">读此便知。</a></p>
<p><del>事故的起因是我把给len数组排序的sort函数右界写错了</del></p>
<h3 id="单调队列">2.单调队列</h3>
<blockquote>
<p>“如果有人比你小还比你强，那你就可以退役了。”</p>
</blockquote>
<p>每次我看见单调队列，我就要把这句话粘过来。</p>
<p>单调队列对于dp的优化参见动态优化一节。</p>
<h6 id="e.g.洛谷p1440-求m区间内的最小值">e.g.<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1440">[洛谷P1440]
求m区间内的最小值</a></h6>
<p><del>这个题用ST表会MLE两个点</del></p>
<p>code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">deque&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;dq; <span class="comment">//&lt;pos,val&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tmp);</span><br><span class="line">        <span class="comment">// cin&gt;&gt;tmp;    //这个题用iostream还真就不行</span></span><br><span class="line">        <span class="keyword">if</span>(dq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;0&lt;&lt;endl;</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!dq.<span class="built_in">empty</span>() <span class="keyword">and</span> dq.<span class="built_in">front</span>().first&lt;(i-m+<span class="number">1</span>))dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() <span class="keyword">and</span> dq.<span class="built_in">back</span>().second&gt;=tmp)&#123;</span><br><span class="line">        <span class="comment">//千万注意危险内存访问！！！！！！！一定要判断非空！！！！！！</span></span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i,tmp));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dq.<span class="built_in">front</span>().second);</span><br><span class="line">        <span class="comment">// cout&lt;&lt;dq.front().second&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈">栈</h2>
<h3 id="单调栈">1. 单调栈</h3>
<h2 id="并查集">并查集</h2>
<h3 id="基本并查集">1. 基本并查集</h3>
<p>初始化时让自己的父节点指向自己，每当需要合并时，将一方的父节点指向另一方即可，最终统计父亲是自己的根节点即可</p>
<h3 id="按秩合并">2. 按秩合并</h3>
<p>如果我们随意地将一个节点直接挂在另一个节点下面，可能会让整棵关系树变得十分不平衡。所以我们可以维护一个参数来表示某个节点的子树深度，并在合并时让深度小的合并在深度大的后面，这样合并得到的树的深度就不会超过合并前两者的最大树深。这种操作可以大幅减少查找的路径长度。</p>
<figure>
<img
src="https://img-blog.csdn.net/20180204183138234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FpdF9ub3RoaW5nX2Fsb25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"
alt="这里写图片描述" />
<figcaption aria-hidden="true">这里写图片描述</figcaption>
</figure>
<h3 id="路径压缩">3. 路径压缩</h3>
<p>加上按秩合并与路径压缩的并查集均摊复杂度可以达到<span
class="math inline">\(O(n\alpha(n))\)</span>（<span
class="math inline">\(\alpha(n)\)</span>为反阿克曼函数，趋近于常数）的优秀复杂度，接近于线性。</p>
<h3 id="扩展域并查集">4. 扩展域并查集</h3>
<p>对于节点1<sub>n，我们可以用1+n</sub>2n的节点编号来作为反集，1与1+n，2与2+n等等互斥。与一个节点的反集合并可以表达两个节点互斥。</p>
<p>由此而类推，我们也可以用更多的空间来维护出更多的关系，这就是扩展域并查集。</p>
<h6 id="e.g.1-p1525-关押罪犯">e.g.1 <a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1525">P1525 关押罪犯</a></h6>
<p>一个并查集参考代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,cnt;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">40002</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> f,t,v;</span><br><span class="line">&#125;edge[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[a] == a)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span>(fa[a] = <span class="built_in">find</span>(fa[a]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;edge[i].f&gt;&gt;edge[i].t&gt;&gt;edge[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edge+<span class="number">1</span>,edge+m+<span class="number">1</span>,[](node a,node b)&#123;<span class="built_in">return</span> (a.v&gt;b.v);&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(edge[i].f) == <span class="built_in">find</span>(edge[i].t))&#123;</span><br><span class="line">            cout&lt;&lt;edge[i].v&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fa[<span class="built_in">find</span>(edge[i].t+n)] = <span class="built_in">find</span>(edge[i].f);</span><br><span class="line">        fa[<span class="built_in">find</span>(edge[i].f+n)] = <span class="built_in">find</span>(edge[i].t);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（这个题好像也可以二分图来着</p>
<h6 id="e.g.2-p2024-食物链">e.g.2 <a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2024">P2024 食物链</a></h6>
<p>参考文章：<a
target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41645482/article/details/97391572">拓展域并查集详解
（食物链+Mahmoud and a Dictionary）</a></p>
<p>这个题更是经典的扩展域并查集题目</p>
<p>A吃B，B吃C，C吃A，那么我们就需要三个并查集，也就是原数组扩展3倍。</p>
<p>我们用与x合并表示为同类，与x+n合并表示为x的猎物，与x+2*n合并表示为x的天敌</p>
<p>A和B是同类说明了：</p>
<ol type="1">
<li>A和B在同一并查集</li>
<li>A+n和B+n在同一并查集</li>
<li>A+2*n和B+2*n在同一并查集。</li>
</ol>
<p>A吃B说明了：</p>
<ol type="1">
<li><p>A+n和B是同类</p></li>
<li><p>A+2*n和B+n是同类</p></li>
<li><p>A和B+2*n是同类（要注意猎物的猎物是天敌）</p></li>
</ol>
<p>之后看题意写程序即可。</p>
<p>code：</p>
<h2 id="树状数组">树状数组</h2>
<p>树状数组是一种短小精悍的数据结构，应用范围类似于线段树，但其维护的信息比较简单，结构不如线段树完全。</p>
<h3 id="树状数组的基本模板">1. 树状数组的基本模板</h3>
<h4 id="lowbit函数">lowbit函数</h4>
<p><code>lowbit(x)</code>函数用于表示x中最小的1的位置，可用<code>x&amp;(-x)</code>的方式求得</p>
<h4 id="code">code</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> tree[<span class="number">500100</span>],n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(x&amp;(-x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;    <span class="comment">//区间查询</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        ans += tree[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;    <span class="comment">//单点修改</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">        tree[i]+=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        cin&gt;&gt;tmp;</span><br><span class="line">        <span class="built_in">add</span>(i,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> opt;</span><br><span class="line">        cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x,k;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;k;</span><br><span class="line">            <span class="built_in">add</span>(x,k);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(opt == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            cout&lt;&lt;(<span class="built_in">query</span>(y)-<span class="built_in">query</span>(x<span class="number">-1</span>))&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为树状数组维护了数列的前缀和，所以也可以利用差分的思想将树状数组改为区间修改和单点查询。只需要将维护的数据改为差分数组，然后改一改函数的调用即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">500100</span>],tree[<span class="number">500100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lb</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i+=<span class="built_in">lb</span>(i))&#123;</span><br><span class="line">		tree[i]+=k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i;i-=<span class="built_in">lb</span>(i))&#123;</span><br><span class="line">		ans+=tree[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">add</span>(i,a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> opt;</span><br><span class="line">		cin&gt;&gt;opt;</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="type">int</span> x,y,k;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			<span class="built_in">add</span>(x,k); <span class="built_in">add</span>(y+<span class="number">1</span>,-k);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> x;</span><br><span class="line">			cin&gt;&gt;x;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">query</span>(x)&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们既需要区间查询、区间修改，还需要单点查询、单点修改要怎么办呢？</p>
<p>线段树，请。</p>
<h3 id="利用树状数组求解逆序对">2. 利用树状数组求解逆序对</h3>
<p>除了利用归并排序，还可以用树状数组来求解逆序对。</p>
<h6 id="e.g.-p8593kdoi-r2csp-s组模拟赛-t1-一个弹的投">e.g. <a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P8593?contestId=79091">[P8593][KDOI
R2/CSP-S组模拟赛-T1] 一个弹的投</a></h6>
<p>利用我们掌握熟练（迫真）的高一物理知识可以知道，在同一时刻开始自由落体的一组物体在竖直方向上是相对静止的，<strong>因此，起始高度不相同的导弹不可能发生碰撞</strong>，并且题目显眼地给出了位移计算公式，不难想到只要相同起始高度的两个导弹的起始横坐标和终止横坐标轴发生了交换，那么就一定出现了碰撞。这样，我们可以通过求逆序对来得到导弹的最大威胁。之后利用贪心的思想，拦截威胁最大的导弹即可。</p>
<h3 id="一些小寄巧">3. 一些小寄巧</h3>
<ol type="1">
<li>将修改和查询中的<code>+lowbit</code>和<code>-lowbit</code>互换，可以视为在维护后缀和；</li>
<li>树状数组的区间加和求区间和操作是比正常写法的线段树块很多的，
具体的写法可以看做两个树状数组，一个维护原数组，一个维护 前缀和。</li>
<li>树状数组的一个小卡常，例如要在 x 处 +z，y 处 −z，可以 x, y
一起跳，每次跳小的一边，两个跳到同一位置就立刻退出，实测很有效。</li>
</ol>
<h4 id="olog-n查询第k小大元素"><span class="math inline">\(O(\log
n)\)</span>查询第k小（大）元素</h4>
<h2 id="st表">ST表</h2>
<h3 id="介绍">介绍</h3>
<p>ST表是一种用于解决<strong>可重复贡献问题</strong>的数据结构。</p>
<p>什么是可重复贡献问题？简单地说，如果区间运算满足<span
class="math inline">\(x \mathrm{opt} x = x\)</span>，比如<span
class="math inline">\(\gcd(x,x)\)</span>或<span
class="math inline">\(\max(x,x)\)</span>，那么对区间的询问就是一个可重复贡献问题，比如区间最值（RMQ）、区间gcd，而区间和就不行。</p>
<p>ST表基于倍增的思想，可以做到<span class="math inline">\(O(n\log
n)\)</span>预处理，<span
class="math inline">\(O(1)\)</span>回答每个询问，但是<strong>不支持修改</strong>。</p>
<p>因为ST表维护的区间是可重复贡献的，所以只要我们找到两个区间的并是我们所求，即使两个区间有重合，也不会影响答案的求解。我们可以用至多两个区间来处理任意一个询问区间，从而达到<span
class="math inline">\(O(1)\)</span>的询问回答。</p>
<h3 id="实现">实现</h3>
<p>以维护RMQ为例。</p>
<p>我们令<span class="math inline">\(f(i,j)\)</span>来表示区间<span
class="math inline">\([i,i+2^j-1]\)</span>（注意区间全闭）的最大值，可得递推式为<span
class="math inline">\(f(i,j) =
\max(f(i,j-1),f(i+2^{j-1},j-1))\)</span>，且易得初始状态为<span
class="math inline">\(f(i,0)=num_i\)</span>，这就是预处理阶段。</p>
<p>而对于每一个询问<span
class="math inline">\([l,r]\)</span>，我们都可以将其视为为区间<span
class="math inline">\([l,l+2^s-1]\)</span>和<span
class="math inline">\([r-2^s,r]\)</span>（其中<span
class="math inline">\(s=\lfloor
\log_2(l-r+1)\rfloor\)</span>）的并。因为贡献可重复，直接求<span
class="math inline">\(\max\left(f(l,s),f(r-2^s,s)\right)\)</span>即为答案。</p>
<p>那么，<span class="math inline">\(\lfloor \log_2(len)
\rfloor\)</span>应该如何求呢？我们固然可以使用<code>log()</code>，但是其实只需要递推或递归预处理一下就可以了。有：
<span class="math display">\[
log[n]=
\begin{cases}
0&amp;n=1\\
log[\frac{n}{2}]+1&amp;n&gt;1
\end{cases}
\]</span> code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">l2g</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">l2g</span>(a/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进而可得全部代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> num[M];</span><br><span class="line"><span class="type">int</span> f[M][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">l2g</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">l2g</span>(a/<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">1</span>,l,r,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=num[i];    <span class="comment">//初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++)&#123;</span><br><span class="line">            f[i][j]=<span class="built_in">min</span>(f[i][j<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;j)][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i-m&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            l=<span class="number">1</span>;r=i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l=i-m;r=i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">l2g</span>(r-l+<span class="number">1</span>);</span><br><span class="line">        cout&lt;&lt;<span class="built_in">min</span>(f[l][len],f[r-(<span class="number">1</span>&lt;&lt;(len))+<span class="number">1</span>][len])&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，ST表还有一个致命的问题，那就是二维数组不能开太大，内存限制比较严格的时候可能不能使用。另外，f数组的第二维大小j不需要太大，只要保证<span
class="math inline">\(2^j&gt;n\)</span>即可。一般这个数会在25左右。</p>
<h2 id="线段树">线段树</h2>
<p>线段树是一个很优秀的树结构，功能多，可以维护复杂信息，还可以动态开点，可以在<span
class="math inline">\(O(\log
N)\)</span>的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。</p>
<blockquote>
<p>线段树维护的信息在很多时候可以认为是满足（幺）半群的性质的信息。 ——OI
wiki</p>
</blockquote>
<h3 id="线段树的基本模板">1. 线段树的基本模板</h3>
<p>线段树的根源就是一个二叉树，用<strong>一个节点来代表一个区间</strong>，过程中会将一个区间不断二分，直到区间里只有一个点为止，作为二叉树的子结点。</p>
<p>当我们在每一层自上而下、从左到右地给这棵二叉树的所有节点命名以后，对于一个节点<span
class="math inline">\(x\)</span>，其的左右儿子就确定为<span
class="math inline">\(2x\)</span>（可以写成<code>x&lt;&lt;2</code>）和<span
class="math inline">\(2x+1\)</span>（<code>x&lt;&lt;2|1</code>）。</p>
<p>一个端点为n的线段树最坏情况下会有4n-1个节点（设倒数第二层是n个,那么第1-&gt;(n-1)层总共最多(n-1)个,最后一层2n个,可得），所以要开出4n的空间以免越界。</p>
<ol type="1">
<li><p>建树函数<code>build()</code></p>
<p>这是一个初始化过程，利用递归来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> u)</span></span>&#123;	<span class="comment">//u用于表示[l,r]区间代表的节点的编号</span></span><br><span class="line">    lzy[u]=<span class="number">0</span>;	<span class="comment">//lazy标签最后说</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        tree[u] = num[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,u*<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,u*<span class="number">2</span>+<span class="number">1</span>);   <span class="comment">//前面几行用于递归寻找叶子结点并赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pushup</span>(u);      <span class="comment">//使叶节点建立好以后立刻向次级节点回溯，求出整棵树的正确初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>pushup()</code></p>
<p>pushup的作用是用子结点的数据更新父节点，保证父节点最新</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tree[u] = tree[<span class="number">2</span>*u]+tree[<span class="number">2</span>*u+<span class="number">1</span>];    <span class="comment">//区间和维护可以替换成一切满足结合律的操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pushup()用于更新维护的数据，参数是父节点</span></span><br></pre></td></tr></table></figure></li>
<li><p>查询函数<code>query()</code></p>
<p>线段树的查询利用分块的思路，先找到被查询区间完全覆盖的区间，直接加上，然后去找部分覆盖的，一步一步递归直到区间被完全覆盖时</p>
<p>线段数的查询时间复杂度为<span
class="math inline">\(O\left(\log(n)\right)\)</span>级别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;   </span><br><span class="line"><span class="comment">//[l,r]表示查询的区间，[L,R]表示线段树节点代表的区间(初始为[1,n])</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=L <span class="keyword">and</span> r&gt;=R)<span class="keyword">return</span> tree[u];</span><br><span class="line">    <span class="type">int</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;R <span class="keyword">or</span> r&lt;L)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(u,L,R);	<span class="comment">//与lazy tag有关</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="built_in">query</span>(u*<span class="number">2</span>,L,mid,l,r)+<span class="built_in">query</span>(u*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,R,l,r));  </span><br><span class="line">    <span class="comment">//U的值和线段树区间对应</span></span><br><span class="line">    <span class="comment">/*这种写法等价于在上一层提前判断分块的时候有没有越过中点，如没有就只查询中点的一边的写法：</span></span><br><span class="line"><span class="comment">        if(l&lt;=mid)query(u,L,M,l,r);</span></span><br><span class="line"><span class="comment">        if(r&gt;mid)query(u*2+1,M+1,R,l,r);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单点修改</p>
<p>改完叶子结点直接pushup即可。</p>
<p>单点修改的复杂度也是<span
class="math inline">\(\log(n)\)</span>的。</p></li>
<li><p>区间修改与lazy标签</p>
<p>如果用单点修改来进行区间修改，那么一次修改的复杂度会是<span
class="math inline">\(O(n)\)</span>的。</p>
<p>优化？</p>
<p>如果我们要修改的区间里包含了一个完整的区间，那么可以直接在这个区间节点上加一个lazy标签，记录上这个区间的修改量，表示这个区间的所有子结点都需要加上这个值，之后就不再下传，等到什么时候需要更小的子区间再去下传。这样，修改的复杂度也可以降至<span
class="math inline">\(O(\log(n))\)</span>。</p></li>
<li><p>下传函数<code>pushdown()</code></p>
<p>pushdown操作则是为了将父节点上的lazy标签更新到子结点上。</p>
<p>在区间修改和区间查询时，都需要pushdown。</p>
<p>最后是洛谷深进风格线段树代码（无单点修改）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本代码可通过P3372</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">ll num[M],lzy[M*<span class="number">4</span>],tree[M*<span class="number">4</span>];</span><br><span class="line"><span class="comment">//num表示原数列，tree表示维护的数据;</span></span><br><span class="line"><span class="comment">//如果按照堆的形式存储数据，则编号U的左子节点是2*U，右子节点则为2*U-1，可以直接利用这个性质来维护结构</span></span><br><span class="line"><span class="comment">/*二叉树并不一定是完全的，所以虽然数量上只有2n-1个节点，</span></span><br><span class="line"><span class="comment">但是标号可能一直到4n-1，因此//这里lzy记录的是子树的修改，所以本层的区间和就直接改掉了。</span></span><br><span class="line"><span class="comment">    				//也可以不应用到父区间，但是其他操作也要注意统一这个细节空间要开四倍。空间利用可以用离散化的方式进一步优化。*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tree[u] = tree[<span class="number">2</span>*u]+tree[<span class="number">2</span>*u+<span class="number">1</span>];    <span class="comment">//区间和维护，可以替换成一切满足结合律的操作</span></span><br><span class="line">&#125;<span class="comment">//用于更新维护的数据，参数是父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    lzy[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        tree[u] = num[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,u*<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid+<span class="number">1</span>,r,u*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pushup</span>(u);      <span class="comment">//使用pushup使叶节点建立好以后立刻向次级节点回溯，构建出整棵树的初始状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tag</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,ll v)</span></span>&#123;	<span class="comment">//用来打lazy标签</span></span><br><span class="line">    lzy[u]+=v;      </span><br><span class="line">    tree[u]+=(r-l+<span class="number">1</span>)*v；</span><br><span class="line">        <span class="comment">//这里lzy记录的是子树的修改，所以本层的区间和就直接改掉了。</span></span><br><span class="line">    	<span class="comment">//也可以不应用到父区间，但是其他操作也要注意统一这个细节</span></span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="type">void</span> <span class="built_in">pushdown</span>(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)&#123;   <span class="comment">//pushdown只下传一层，参数为父节点，且没有边界判断</span></span><br><span class="line">    <span class="type">int</span> m = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">tag</span>(u*<span class="number">2</span>,l,m,lzy[u]);</span><br><span class="line">    <span class="built_in">tag</span>(u*<span class="number">2</span>+<span class="number">1</span>,m+<span class="number">1</span>,r,lzy[uxian duan shu |]);</span><br><span class="line">    lzy[u] = <span class="number">0</span>;     <span class="comment">//lzy标签用完要清空！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;   </span><br><span class="line">    <span class="comment">//[l,r]表示查询的区间，[L,R]表示线段树节点代表的区间</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;=L <span class="keyword">and</span> r&gt;=R)<span class="keyword">return</span> tree[u];</span><br><span class="line">    <span class="type">int</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;R <span class="keyword">or</span> r&lt;L)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(u,L,R);</span><br><span class="line">    <span class="keyword">return</span>(<span class="built_in">query</span>(u*<span class="number">2</span>,L,mid,l,r)+<span class="built_in">query</span>(u*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,R,l,r));  </span><br><span class="line">    <span class="comment">//U的值和线段树区间对应</span></span><br><span class="line">    <span class="comment">/*这一步等价于在上一层提前判断分块的时候有没有越过中点，如没有就只查询中点的一边的写法：</span></span><br><span class="line"><span class="comment">        if(l&lt;=mid)query(u,L,M,l,r);</span></span><br><span class="line"><span class="comment">        if(r&gt;mid)query(u*2+1,M+1,R,l,r);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> l,<span class="type">int</span> r,ll v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=L <span class="keyword">and</span> r&gt;=R)&#123;</span><br><span class="line">        <span class="built_in">tag</span>(u,L,R,v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//不难发现tag最多会在叶子结点的上一层出现，不会越界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;R <span class="keyword">or</span> r&lt;L)<span class="keyword">return</span>; </span><br><span class="line">    <span class="comment">// cout&lt;&lt;u&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">int</span> mid = (L+R)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(u,L,R);</span><br><span class="line">    <span class="built_in">update</span>(u*<span class="number">2</span>,L,mid,l,r,v);</span><br><span class="line">    <span class="built_in">update</span>(u*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,R,l,r,v);</span><br><span class="line">    <span class="built_in">pushup</span>(u);</span><br><span class="line">    <span class="comment">/*这个时候u的子树是都新的，但是u的值因为没有完全属于选中的[l,r]区间而没有被更新，但又因为部分子树作为[l,r]子集</span></span><br><span class="line"><span class="comment">    而更新，导致u上的值受到影响，所以需要在自下而上更新一下u的数据*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">// cin&gt;&gt;num[i];</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin&gt;&gt;op;tong yi |</span><br><span class="line">        <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">                <span class="type">int</span> x,y; ll k;</span><br><span class="line">                <span class="comment">// cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span></span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;x,&amp;y,&amp;k);</span><br><span class="line">                <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y,k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">                <span class="type">int</span> x,y;</span><br><span class="line">                <span class="comment">// cin&gt;&gt;x&gt;&gt;y;</span></span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y)zhe ge xi jie |;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,y));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="e.g.1-acwing243一个简单的整数问题-2">e.g.1 <a
target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/244/">[ACwing243]一个简单的整数问题
2</a></h6>
<p>这个模板题可以使用树状数组来通过。</p>
<p>在这里给出y总风格的线段树模板代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M  = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    LL sum,add;		<span class="comment">//add变量即是lazy标签</span></span><br><span class="line">&#125;tr[M*<span class="number">4</span>];	<span class="comment">//这种线段树写法把节点对应的区间和区间和封装在结构体里，整体上更好写</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[M];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u*<span class="number">2</span>].sum+tr[u*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u*<span class="number">2</span>], &amp;right = tr[u*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(root.add)&#123;</span><br><span class="line">        left.add += root.add, left.sum += (LL)(left.r - left.l +<span class="number">1</span>)*root.add;</span><br><span class="line">        right.add += root.add, right.sum+= (LL)(right.r - right.l +<span class="number">1</span>)*root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[u] = &#123;l,r,w[r],<span class="number">0</span>&#125;;	<span class="comment">//这种传参方式只要注意好参数顺序，比分开写要方便的多</span></span><br><span class="line">        <span class="comment">//注意add初始化为0</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l,r&#125;;	<span class="comment">//这个时候sum和add还是原值</span></span><br><span class="line">        <span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(u*<span class="number">2</span>,l,mid),<span class="built_in">build</span>(u*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;	<span class="comment">//d是需要加上的值</span></span><br><span class="line">    <span class="keyword">if</span>(tr[u].l &gt;= l <span class="keyword">and</span> tr[u].r&lt;=r)&#123;</span><br><span class="line">        tr[u].sum += (LL)(tr[u].r-tr[u].l +<span class="number">1</span>)*d;</span><br><span class="line">        tr[u].add += d;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = (tr[u].l+tr[u].r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt;= mid)<span class="built_in">modify</span>(u*<span class="number">2</span>,l,r,d);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">modify</span>(u*<span class="number">2</span>+<span class="number">1</span>,l,r,d);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> u=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].l&gt;= l <span class="keyword">and</span> tr[u].r &lt;= r)<span class="keyword">return</span> tr[u].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = (tr[u].l + tr[u].r)/<span class="number">2</span>;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;= mid)sum += <span class="built_in">query</span>(l,r,u*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)sum += <span class="built_in">query</span>(l,r,u*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n);	<span class="comment">//注意初始化时的参数</span></span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> l,r,d;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            cin&gt;&gt;d;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,l,r,d);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,l,r)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扫描线法">4. 扫描线法</h3>
<h3 id="权值线段树">5. 权值线段树</h3>
<h3 id="zkw线段树">6. zkw线段树</h3>
<p>zkw线段树是一种<strong>非递归线段树</strong>，因为张昆玮在<a
href="https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/0c1bbba40029bd64783e2cca.html">统计的力量</a>
中介绍了这种数据结构，常常被称为<strong>zkw线段树</strong>，是一种代码较短、常数较小的线段树写法。</p>
<h3 id="可持久化数据结构">7. 可持久化数据结构</h3>
<p>可持久化线段树一般用于解决带有历史记录的问题。</p>
<p>可持久化数据结构的核心就是：只记录一个版本和前一个版本不一样的节点的数据</p>
<h4 id="trie的可持久化">trie的可持久化</h4>
<p>可持久化数据结构的写法其实有点类似前缀和，每次只修改被添加或值被修改的节点，而保留没有被改动的节点，在上一个版本的基础上连边，使最后每个版本的
Trie 树的根遍历所能分离出的 Trie 树都是完整且包含全部信息的。</p>
<p>举个例子，加入我们以此在Trie中插入了cat，cup，soup，cut四个单词：</p>
<ul>
<li><p>第一次插入，所有的点都是新的，所以直接建出所有的边 <img
src="https://img-blog.csdnimg.cn/ea84867bd6094779b96edf27f9bc9728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p3ZzI3MzI=,size_16,color_FFFFFF,t_70#pic_center" /></p></li>
<li><p>第二个单词插入的时候，c边已经存在过了，就把c指向的点复制一个，这个点既要连接到前一个版本的a边上，又要链接新建的u边
<img
src="https://img-blog.csdnimg.cn/1e6e5ebe26954d60819beaf84ae32e21.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p3ZzI3MzI=,size_16,color_FFFFFF,t_70#pic_center" /></p></li>
<li><p>第三次和第四次同理，最后可得：</p></li>
</ul>
<p><img
src="https://img-blog.csdnimg.cn/3970547310704fac91a1a17ec0761f38.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p3ZzI3MzI=,size_16,color_FFFFFF,t_70#pic_center" /></p>
<p>之后，从第一个根节点到第四个根节点开始遍历，就能得到不同版本的信息。</p>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，有tire的地方就有01-tire。</p>
<h6 id="e.g.-p4735-最大异或和">e.g. <a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4735">[P4735]
最大异或和</a></h6>
<h4 id="线段树的可持久化主席树">线段树的可持久化：主席树</h4>
<p>一次区间修改最多需要更改<span class="math inline">\(O(\log
n)\)</span>的区间，所以可持久化线段树可以在<span
class="math inline">\(O(m\log
n)\)</span>的空间复杂度内完成可持久化的储存。</p>
<p>不过，因为lazy标签难以维护，可持久化线段树难以进行区间修改操作（难以在<span
class="math inline">\(O(n)\)</span>内完成，除非标记永久化）。</p>
<p>和trie不同的是，线段树在中途是不会有新节点出现的，所以整体上要比trie更简单一点（？</p>
<p>当我们修改了树上的一些区间之后，需要把修改过的区间复制出来，并令其连接到没有修改的旧节点上即可。</p>
<h6 id="e.g.1-ac255-第k小数">e.g.1 <a
target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/257/">[AC255]
第k小数</a></h6>
<p>首先，这是一个静态问题，在讯问过程中序列并没有变化，可以使用划分树（特攻型数据结构，不带修改，泛用性不佳，但是<span
class="math inline">\(O(N\log
N)\)</span>）、树套树（线段树套平衡树，带修改，<span
class="math inline">\(O(n\log^2
n)\)</span>）解决，也可以考虑使用可持久化线段树（不带修改，<span
class="math inline">\(O(N\log N)\)</span>）。</p>
<p>如果我们需要</p>
<p>（nth_element() 序列的第n小值）</p>
<h2 id="平衡树">平衡树</h2>
<p>平衡树，全称平衡二叉搜索树。</p>
<h3 id="前置知识二叉搜索树">前置知识：二叉搜索树</h3>
<p>二叉搜索树指的是满足：对于任意一个节点x，左子树的所有点的关键字都比x小，右子树的所有点的关键字都比x大的一种二叉树。</p>
<h3 id="splay">splay</h3>
<h3 id="treap">Treap</h3>
<p>Treap（树堆）是一种<strong>弱平衡</strong>的<strong>二叉搜索树</strong>。它同时符合二叉搜索树和堆的性质，名字也因此为
tree（树）和 heap（堆）的组合。</p>
<h2 id="莫队">莫队</h2>
<p>莫队最早由大犇莫涛发明，故名。</p>
<h2 id="堆">堆</h2>
<p>堆是一种支持<span class="math inline">\(O(logn)\)</span>插入，<span
class="math inline">\(O(1)\)</span>求最大值的数据结构，可以用C++STL中的priority_queue实现，常数较低。用两个堆可以实现删除，常数小于set</p>
<h2 id="笛卡尔树">笛卡尔树</h2>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>本节部分摘自清北学堂国庆训练营，感谢郭龙举提供的材料<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://rockeyleo.github.io">rockeyleo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://rockeyleo.github.io/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%975-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">https://rockeyleo.github.io/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%975-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/">学习手记</a><a class="post-meta__tags" href="/tags/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%97/">csp-noip备战日志</a><a class="post-meta__tags" href="/tags/OI/">OI</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%976-%E5%9B%BE%E8%AE%BA/" title="csp-noip备战日志6-图论"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">csp-noip备战日志6-图论</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%974-%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="csp-noip备战日志4-字符串"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">csp-noip备战日志4-字符串</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/07/20/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%970-5-CSP-S%E5%88%9D%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/" title="csp-noip备战日志0.5-CSP&#x2F;S初试知识点梳理"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-20</div><div class="title">csp-noip备战日志0.5-CSP&#x2F;S初试知识点梳理</div></div></a></div><div><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%971-%E5%B0%8F%E5%AF%84%E5%B7%A7/" title="csp-noip备战日志1-小寄巧"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">csp-noip备战日志1-小寄巧</div></div></a></div><div><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%972-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" title="csp-noip备战日志2-基础算法"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">csp-noip备战日志2-基础算法</div></div></a></div><div><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%974-%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="csp-noip备战日志4-字符串"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">csp-noip备战日志4-字符串</div></div></a></div><div><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%973-%E6%90%9C%E7%B4%A2/" title="csp-noip备战日志3-搜索"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">csp-noip备战日志3-搜索</div></div></a></div><div><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%976-%E5%9B%BE%E8%AE%BA/" title="csp-noip备战日志6-图论"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">csp-noip备战日志6-图论</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/07/22/PFz9shrI5nGAZmx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">rockeyleo</div><div class="author-info__description">胡言乱语集</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/rockeyleo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:rockeyleo@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841"><span class="toc-number">1.</span> <span class="toc-text">五 数据结构1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.1.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 队列的基本应用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.-p2827-noip2016-%E8%9A%AF%E8%9A%93"><span class="toc-number">1.1.1.0.0.1.</span> <span class="toc-text">e.g. [P2827] [NOIP2016]
蚯蚓</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.单调队列</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.%E6%B4%9B%E8%B0%B7p1440-%E6%B1%82m%E5%8C%BA%E9%97%B4%E5%86%85%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">1.1.2.0.0.1.</span> <span class="toc-text">e.g.[洛谷P1440]
求m区间内的最小值</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.2.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 单调栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.3.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 基本并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%A7%A9%E5%90%88%E5%B9%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 按秩合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 路径压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%9F%9F%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. 扩展域并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.1-p1525-%E5%85%B3%E6%8A%BC%E7%BD%AA%E7%8A%AF"><span class="toc-number">1.3.4.0.0.1.</span> <span class="toc-text">e.g.1 P1525 关押罪犯</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.2-p2024-%E9%A3%9F%E7%89%A9%E9%93%BE"><span class="toc-number">1.3.4.0.0.2.</span> <span class="toc-text">e.g.2 P2024 食物链</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">树状数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 树状数组的基本模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lowbit%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">lowbit函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">code</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%B1%82%E8%A7%A3%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 利用树状数组求解逆序对</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.-p8593kdoi-r2csp-s%E7%BB%84%E6%A8%A1%E6%8B%9F%E8%B5%9B-t1-%E4%B8%80%E4%B8%AA%E5%BC%B9%E7%9A%84%E6%8A%95"><span class="toc-number">1.4.2.0.0.1.</span> <span class="toc-text">e.g. [P8593][KDOI
R2&#x2F;CSP-S组模拟赛-T1] 一个弹的投</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%AF%84%E5%B7%A7"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. 一些小寄巧</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#olog-n%E6%9F%A5%E8%AF%A2%E7%AC%ACk%E5%B0%8F%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">\(O(\log
n)\)查询第k小（大）元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#st%E8%A1%A8"><span class="toc-number">1.5.</span> <span class="toc-text">ST表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.2.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.6.</span> <span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 线段树的基本模板</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.1-acwing243%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B4%E6%95%B0%E9%97%AE%E9%A2%98-2"><span class="toc-number">1.6.1.0.0.1.</span> <span class="toc-text">e.g.1 [ACwing243]一个简单的整数问题
2</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%BA%BF%E6%B3%95"><span class="toc-number">1.6.2.</span> <span class="toc-text">4. 扫描线法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.6.3.</span> <span class="toc-text">5. 权值线段树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zkw%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.6.4.</span> <span class="toc-text">6. zkw线段树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.5.</span> <span class="toc-text">7. 可持久化数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#trie%E7%9A%84%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">trie的可持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.-p4735-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C"><span class="toc-number">1.6.5.1.0.1.</span> <span class="toc-text">e.g. [P4735]
最大异或和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%BB%E5%B8%AD%E6%A0%91"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">线段树的可持久化：主席树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.1-ac255-%E7%AC%ACk%E5%B0%8F%E6%95%B0"><span class="toc-number">1.6.5.2.0.1.</span> <span class="toc-text">e.g.1 [AC255]
第k小数</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">1.7.</span> <span class="toc-text">平衡树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.7.1.</span> <span class="toc-text">前置知识：二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#splay"><span class="toc-number">1.7.2.</span> <span class="toc-text">splay</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#treap"><span class="toc-number">1.7.3.</span> <span class="toc-text">Treap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%AB%E9%98%9F"><span class="toc-number">1.8.</span> <span class="toc-text">莫队</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.9.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91"><span class="toc-number">1.10.</span> <span class="toc-text">笛卡尔树</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/02/20/%E6%BA%A2%E5%85%89%E4%BA%AD%EF%BC%8C%E5%A0%82%E5%A0%82%E5%A4%8D%E6%B4%BB%EF%BC%81/" title="溢光亭，堂堂复活！"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="溢光亭，堂堂复活！"/></a><div class="content"><a class="title" href="/2025/02/20/%E6%BA%A2%E5%85%89%E4%BA%AD%EF%BC%8C%E5%A0%82%E5%A0%82%E5%A4%8D%E6%B4%BB%EF%BC%81/" title="溢光亭，堂堂复活！">溢光亭，堂堂复活！</a><time datetime="2025-02-20T05:50:26.000Z" title="Created 2025-02-20 13:50:26">2025-02-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/MIT-Missing-Semester%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MIT-Missing-Semester学习笔记"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MIT-Missing-Semester学习笔记"/></a><div class="content"><a class="title" href="/2023/07/24/MIT-Missing-Semester%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MIT-Missing-Semester学习笔记">MIT-Missing-Semester学习笔记</a><time datetime="2023-07-24T14:15:07.000Z" title="Created 2023-07-24 22:15:07">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%979-%E6%9D%82%E9%A1%B9/" title="csp-noip备战日志9-杂项"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="csp-noip备战日志9-杂项"/></a><div class="content"><a class="title" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%979-%E6%9D%82%E9%A1%B9/" title="csp-noip备战日志9-杂项">csp-noip备战日志9-杂项</a><time datetime="2023-07-21T13:26:50.000Z" title="Created 2023-07-21 21:26:50">2023-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%978-%E6%95%B0%E5%AD%A6/" title="csp-noip备战日志8-数学"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="csp-noip备战日志8-数学"/></a><div class="content"><a class="title" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%978-%E6%95%B0%E5%AD%A6/" title="csp-noip备战日志8-数学">csp-noip备战日志8-数学</a><time datetime="2023-07-21T13:26:35.000Z" title="Created 2023-07-21 21:26:35">2023-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%977-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="csp-noip备战日志7-动态规划"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="csp-noip备战日志7-动态规划"/></a><div class="content"><a class="title" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%977-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="csp-noip备战日志7-动态规划">csp-noip备战日志7-动态规划</a><time datetime="2023-07-21T13:26:23.000Z" title="Created 2023-07-21 21:26:23">2023-07-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By rockeyleo</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '66861e99fcf865283026',
      clientSecret: '8771be818c9e77873da42d2073ecdddab5c8ed92',
      repo: 'rockeyleo.github.io',
      owner: 'rockeyleo',
      admin: ['rockeyleo'],
      id: 'af7d11dfbb43688c6965611c819861ba',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>