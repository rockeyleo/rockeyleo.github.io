<!DOCTYPE html><html lang="zh_CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>csp-noip备战日志7-动态规划 | 溢光亭</title><meta name="author" content="rockeyleo"><meta name="copyright" content="rockeyleo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="七 动态规划 即使你可以用各种暴力来骗取dp的分数，dp背后的思维仍旧十分重要。 线性DP 所谓线性dp,是指状态之间有线性关系的一类dp问题。 动态规划初步·各种子序列问题 —皎月半洒花 e.g.1 [洛谷P1216] [USACO1.5][IOI1994]数字三角形 Number Triangles 记忆化搜索 e.g.2 最长上升子序列（LIS） 首先明确一点，子序列不一定是连续的。 如果我">
<meta property="og:type" content="article">
<meta property="og:title" content="csp-noip备战日志7-动态规划">
<meta property="og:url" content="https://rockeyleo.github.io/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%977-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="溢光亭">
<meta property="og:description" content="七 动态规划 即使你可以用各种暴力来骗取dp的分数，dp背后的思维仍旧十分重要。 线性DP 所谓线性dp,是指状态之间有线性关系的一类dp问题。 动态规划初步·各种子序列问题 —皎月半洒花 e.g.1 [洛谷P1216] [USACO1.5][IOI1994]数字三角形 Number Triangles 记忆化搜索 e.g.2 最长上升子序列（LIS） 首先明确一点，子序列不一定是连续的。 如果我">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-07-21T13:26:23.000Z">
<meta property="article:modified_time" content="2023-08-20T05:45:45.597Z">
<meta property="article:author" content="rockeyleo">
<meta property="article:tag" content="学习手记">
<meta property="article:tag" content="csp-noip备战日志">
<meta property="article:tag" content="OI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://rockeyleo.github.io/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%977-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'csp-noip备战日志7-动态规划',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-20 13:45:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/my.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/07/22/PFz9shrI5nGAZmx.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="溢光亭"><span class="site-name">溢光亭</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">csp-noip备战日志7-动态规划</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-07-21T13:26:23.000Z" title="Created 2023-07-21 21:26:23">2023-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-20T05:45:45.597Z" title="Updated 2023-08-20 13:45:45">2023-08-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="csp-noip备战日志7-动态规划"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="七-动态规划">七 动态规划</h1>
<p>即使你可以用各种暴力来骗取dp的分数，dp背后的思维仍旧十分重要。</p>
<h2 id="线性dp">线性DP</h2>
<p>所谓线性dp,是指状态之间有线性关系的一类dp问题。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/pks-LOVING/junior-dynamic-programming-dong-tai-gui-hua-chu-bu-ge-zhong-zi-xu-lie">动态规划初步·各种子序列问题 —皎月半洒花</a></p>
<h6 id="e.g.1-洛谷p1216-usaco1.5ioi1994数字三角形-number-triangles">e.g.1 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1216">[洛谷P1216] [USACO1.5][IOI1994]数字三角形 Number Triangles</a></h6>
<p><del>记忆化搜索</del></p>
<h6 id="e.g.2-最长上升子序列lis">e.g.2 最长上升子序列（LIS）</h6>
<p>首先明确一点，<strong>子序列不一定是连续的。</strong></p>
<p>如果我们用<code>dp[i]</code>来表示<strong>以i为结尾的序列的最大长度</strong>，一开始将dp数组都初始化为1（一个以i为结尾的序列的长度至少为1，当这个数列只有它自己时），之后我们从数列的第一个数开始遍历，对于每一个<code>dp[i]</code>，遍历i前面的所有数字<code>num[j]</code>。如果<code>num[j]</code>满足<code>num[j]&lt;num[i]</code>，那我们就试着把这个以j结尾的最长串后面直接接上i，来尝试更新以i结尾的最长序列长度。有<code>dp[i] = max(dp[i],dp[j]+1)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from 皎月半洒花</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[j]&lt;num[i])&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于答案，应该是dp数组中元素的最大值，我们就有了一个<span class="math inline">\(O(n^2)\)</span>的做法。</p>
<p>注意：因为<code>memset()</code>的工作原理，<strong>不能使用<code>memset()</code>将数组初始化为1</strong>，只有0x3f（表示的其实是0x3f3f3f3f/1061109567），0，-1（-1的补码恰好全是1）是较为安全的。</p>
<p><em>优化？</em></p>
<p>贪心地想，如果有两个长度相同的序列，那么我们一定先选结尾的数字小的那一个，以便于继续向后合并出更长的序列。由此我们可以产生一个新的思路：用<code>f[i]</code>来表示长度为i的子序列的最小末尾元素，<code>f[i]</code>可初始化为一个极大值。至于答案求解，统计最大的有效数组长度(不等于初值的就是有效的)，即为答案。也可以另f是一个vector容器，vector的<code>size()</code>即为答案。</p>
<p>来看看状态设计：</p>
<p>设原始序列为<code>num</code>，显然我们有<code>f[1]=a[1]</code>。因为我们的<code>f[i]</code>储存了长度为i的子序列的最小末尾值，所以显然<code>f[i+1]</code>表示的数列一定是由<code>f[i]</code>表示的数列加上一个数（这个数就是<code>f[i+1]</code>自己）转移而来的。按照子序列的单调性，一定有<code>f[i]&lt;f[i+1]</code>，f数组满足单调性。所以，当我们从1到n遍历num数组的时候，设<code>x:&#123;1-&gt;n&#125;</code>，一旦遇到了一个比<code>f[cnt]</code>（一开始cnt=1）大的数，就暂时扩展f数组，令<code>f[++cnt]=num[x]</code>。如果这个数比<code>f[cnt]</code>要小，那么就往f数组的前面找，直到找到一个刚好比<code>num[x]</code>大的，用<code>num[x]</code>来更新数组f。这个过程我们可以使用<code>upeer_bound()</code>来实现。</p>
<p>这样做有什么好处呢？我们在寻找这个刚好比<code>num[x]</code>小的<code>f[n]</code>的时候，可以利用二分查找的方法在<span class="math inline">\(O(\log n)\)</span>的时间内完成（upper_bound和lower_bound内部就是二分查找）。这样，算法的总体时间复杂度就被优化为<span class="math inline">\(O(n\log n)\)</span>。</p>
<p><em>延伸阅读：<code>lower_bound()/upper_bound()</code>的使用</em></p>
<p><code>lower_bound()</code>函数用于在指定区域内查找<strong>不小于</strong>目标值的第一个元素，一般用于查找最长不下降子序列，而<code>upper_bound()</code>则是查找<strong>小于</strong>目标值的第一个元素，一般用于求解最长上升子序列。这两个函数均需要三个参数：被查找序列的开头、结尾，以及要查找的元素。函数将会返回一个指针或迭代器（取决于使用数组还是vector），指向这个元素。</p>
<h4 id="e.g.2.1-p1020noip1999-普及导弹拦截">e.g.2.1 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1020">[P1020][NOIP1999 普及]导弹拦截</a></h4>
<p>这个题的第一问求的是最长不上升子序列，做法类似，不再赘述；至于第二问，我们可以考虑贪心。</p>
<p>当我们需要拦截一个导弹的时候， 一定是优先选择大于导弹高度的拦截高度最矮的系统，来保证最大利用率。如果找到了，就更新系统的高度；如果找不到，就说明需要一套新的，并且新系统此时的高度就应为导弹的高度。二分代码写出来，其实就是在求序列的最长上升子序列。</p>
<p>还有一个我自己不成熟的思路：其实这个贪心的过程，和我们求LIS的nlogn做法不谋而合。显然，如果我们的每一套系统都在剩余的导弹中选择最长不下降子序列拦截，效率是最高的。并且，每一个最长不下降子序列，总是试图寻找一个最大的高度作为起始，所以似乎我们可以通过求最长上升子序列来得到需要的系统数量。它的正确性，与Dilworth定理紧密相连。Dilworth的定理内容是：</p>
<blockquote>
<p><strong>偏序集能划分成的最少的全序集个数等于最大反链的元素个数。</strong> -&gt;将一个序列剖成若干个单调不升子序列的最小个数等于该序列最长上升子序列的个数。</p>
</blockquote>
<p>（<a target="_blank" rel="noopener" href="https://tofu.blog.luogu.org/pian-xu-ji-ha-si-tu-yu-dilworth-ding-li">具体证明可看这篇博客</a>）</p>
<h6 id="e.g.3-洛谷p1439最长公共子序列lcs">e.g.3 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1439">[洛谷P1439]最长公共子序列</a>（LCS）</h6>
<p>状态设计：设原数列为A和B，我们用<code>dp[i][j]</code>来表示A串的前i位和第B串的前j位的LCS的长度，则不难得到：</p>
<ul>
<li>若<code>A[i]=B[j]</code>，则<code>dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1)</code></li>
<li>若<code>A[i]!=B[i]</code>，则考虑继承：<code>dp[i][j] = max(dp[i-1][j],dp[i][j-1])</code></li>
</ul>
<p>不过，<span class="math inline">\(O(n^2)\)</span>的做法不足以通过此题。<em>有没有别的思路呢？</em></p>
<p>您好，有的。对于两个序列A，B，如果我们给A重新编号，使其变成一个单调上升的序列A'，再用这些映射对B进行重编号，得到一个B'，我们就能惊喜地发现，B‘的所有上升子序列就都是A’的子序列了！也就是说，<strong>我们只需要求B'的LIS就可以了</strong>。以及显然，<strong>这种转化只能适用于P1439这种规定了A，B序列均为为自然数 <span class="math inline">\(1,2,\ldots,n\)</span> 的一个排列“的题型</strong>。因为只有在这个时候，A才能保证可以转化为一个单调序列。</p>
<h6 id="e.g.4-p5664-csp-s2019-emiya家今天的饭">e.g.4 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5664">P5664 [CSP-S2019] Emiya家今天的饭</a></h6>
<h2 id="背包九讲">背包九讲</h2>
<p><del>典中典了属于是</del></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1qt411Z7nE/">yxc背包九讲视频</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jbelial/articles/2116074.html">背包九讲原文</a></p>
<h3 id="背包问题">1. 01背包问题</h3>
<h4 id="状态的表示">状态的表示</h4>
<p><code>f[i][j]</code> 用于表示只看前i个物品，总体积是j的情况下，总价值最大是多少</p>
<p>答案即为<code>max&#123;f[n][0~v]&#125;</code></p>
<h4 id="状态转移">状态转移</h4>
<p>对于第i个物品：</p>
<ul>
<li>不选第i个物品时，<code>f[i][j] = f[i-1][j]</code></li>
<li>选第i个物品时，<code>f[i][j] = f[i-1][j-v[i]]+w[i]</code></li>
</ul>
<p>每次判断上两者哪个最大即可。</p>
<h4 id="初始化">初始化</h4>
<p><code>f[i][j] = max(f[i-1][j],f[i-1][j-v[i]]+w[i])</code></p>
<p><code>f[0][0] = 0</code></p>
<h4 id="复杂度oleftn2-right">复杂度：<span class="math inline">\(O\left(n^2 \right)\)</span></h4>
<h4 id="code">code:</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">1001</span>],w[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i])&#123;	<span class="comment">//要保证背包剩余空间是足够的</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)res = <span class="built_in">max</span>(res,f[n][i]);</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优化滚动数组">优化：滚动数组</h4>
<p>二维数组毕竟不能存储很大的数据，能不能用一个一维数组来表示呢？</p>
<p>如果我们把第一维去掉怎么样？</p>
<p>那么<code>f[i-1][j]</code>这一项没有区别，因为在<code>f[j]</code>被这一层循环的计算值覆盖之前，存的就是上一层的f[j]；但是<code>f[i-1][j-v[i]]</code>就不行了。原因是在第i层循环上，<code>f[i][j-v[i]]</code>比<code>f[i][j]</code>先算，表明我们使用<code>f[j-v[i]]</code>的时候，数据实际上已经被本层循环的<code>f[i][j-v[i]]</code>覆盖了。所以，每一层的j我们都需要逆序查询。</p>
<p>而答案直接输出<code>f[m]</code>即可。</p>
<p>code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">1001</span>],w[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完全背包问题">2. 完全背包问题</h3>
<p>和01背包类似，但是每一个物品可以被选择多次</p>
<p>我们用01背包的思路，可以得到一个-&gt;<span class="math inline">\(O\left(n^3\right)\)</span>的方程：</p>
<p><code>f[i][j] = max(f[i-1][j-k*w[i]]+v[i]*k)</code>，k每个物品表示选择的数量（k可以为0）</p>
<h4 id="优化"><em>优化？</em></h4>
<p>不难发现，对于物品j，存在一个物品i，使得<code>c[i]&lt;=c[j]</code>且<code>w[i]&gt;=w[j]</code>，那么j是不用考虑的。不过，这样并不能降低最坏时间复杂度。</p>
<h4 id="接着优化"><em>接着优化？</em></h4>
<p>不妨用01背包的思路来解决。</p>
<p>对于每一件物品，最多也只能选择<code>v/c[i]</code>次，所以可以直接把一件可以选择多次的物品变成<code>v/c[i]</code>件01背包，这样就转化为了01背包问题。</p>
<p>但是复杂度还是没有变化。继续优化？</p>
<p>我们还可以利用二进制的思路，把第i种物品转化为费用为<span class="math inline">\(c[i]\times 2^k\)</span>，价值为<span class="math inline">\(w[i]\times 2^k\)</span>（<span class="math inline">\(c\times 2^k\le V\)</span>）的若干件物品，这样物品就转化为了<span class="math inline">\(O(]log(V/c[i]))\)</span>件物品，有了一点点优化。这个思路在多重背包里同样也会用到。</p>
<h4 id="能不能降低到ovn"><em>能不能降低到<span class="math inline">\(O(VN)\)</span>？</em></h4>
<p>对于状态<code>f[i][j]</code>，其实只要通过<code>f[i][j-w[i]]</code>转移就可以了。</p>
<p>怎样理解？</p>
<p>实际上这是在考虑</p>
<p>所以状态转移方程就变为<code>f[i][j] = max(f[i-1][j],f[i][j-w[i]]+v[i])</code>，我们成功得到了一个平方级别的解法。</p>
<h4 id="压缩成一维"><em>压缩成一维？</em></h4>
<p>既然有了二维方程，根据01背包问题的思路，不难想到，完全背包的代码其实就是01背包将里面的逆序转为正序就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">1001</span>],w[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重背包问题">3. 多重背包问题</h3>
<p>多重背包和完全背包的区别就是背包中的物品有数量的限制。用最朴素的思路，可以得到：<code>f[i][j] = max&#123;f[i-1][v-k*c[i]] + k*[w[i]]&#125;</code>，其中<span class="math inline">\(0 \le k \le n[i]\)</span></p>
<p>这样的复杂度是<span class="math inline">\(O\left(V\sum n_i\right)\)</span>。</p>
<h4 id="优化-1"><em>优化？</em></h4>
<p>用上面提到的方法，不难将这个问题转化为一个01背包问题，变成一个有<span class="math inline">\(\sum n_i\)</span>个物品的</p>
<p>继续优化也显而易见，就是二维拆分</p>
<p>我们用来表示</p>
<p>可以得到代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(出自OIwiki)</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">1</span>, p, h, k;</span><br><span class="line">  cin &gt;&gt; p &gt;&gt; h &gt;&gt; k;</span><br><span class="line">  <span class="keyword">while</span> (k - c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    k -= c;</span><br><span class="line">    list[++index].w = c * p;</span><br><span class="line">    list[index].v = c * h;</span><br><span class="line">    c *= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  list[++index].w = p * k;</span><br><span class="line">  list[index].v = h * k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继续优化呢"><em>继续优化呢？</em></h4>
<p>考虑单调队列。参见下面的单调队列优化一节。</p>
<h3 id="混合背包问题">4. 混合背包问题</h3>
<p>混合背包就是将前面的三种背包混合起来，有的物品能数一次，有的无限次，有的为1次。</p>
<h6 id="e.g.-p1941-noip2014提高-飞扬的小鸟">e.g. <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1941">P1941 [NOIP2014提高] 飞扬的小鸟</a></h6>
<p>我们用<code>dp[x][y]</code>表示小鸟在<span class="math inline">\((x,y)\)</span>时</p>
<h3 id="二维费用的背包问题">5. 二维费用的背包问题</h3>
<p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量），问怎样选择物品可以得到最大的价值。</p>
<p>设这两种代价分别为代价1和代价2，那么第i件物品所需的两种代价分别为<code>a[i]</code>和<code>b[i]</code> 。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i] 。</p>
<blockquote>
<p>给出n个任务，完成每个任务需要t分钟和c元的开支，现在有T分钟时间，W元钱，求最多能完成多少任务。</p>
</blockquote>
<p>可以在状态中再加一维，用来表示新的代价，所以我们易得：<code>f[i][v][u] = max(f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i])</code></p>
<p>加上滚动数组优化，可以用一个二维数组解决。</p>
<p>注意好代码实现的循环顺序!</p>
<p>这种dp的复杂度一般是立方级别的，看数据范围应该挺好认</p>
<h3 id="分组背包问题">6. 分组背包问题</h3>
<blockquote>
<p>有<span class="math inline">\(N\)</span>件物品和一个大小为<span class="math inline">\(V\)</span>的背包，第<span class="math inline">\(i\)</span>个物品的价值为<span class="math inline">\(w_i\)</span>，费用为<span class="math inline">\(c_i\)</span>，同时，这些物品被分为若干个组，同组内最多只能选择一个物品。求背包能装的最大总价值。</p>
</blockquote>
<p>咋办捏？</p>
<p>其实就是01背包的「从在所有物品中选择一件」变成了「在每一组中选择一件」，于是对每一组进行一次01背包就可以了。</p>
<p>至于储存，可以用<code>t[i][j]</code>表示第k组的第i件物品的编号是多少，再用<code>cnt[k]</code>表示第k组的物品有多少个，然后在第二层循环里面加一个组遍历就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from OIwiki C++ Version</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= ts; k++)          <span class="comment">// 循环每一组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">0</span>; i--)         <span class="comment">// 循环背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt[k]; j++)  <span class="comment">// 循环该组的每一个物品</span></span><br><span class="line">      <span class="keyword">if</span> (i &gt;= w[t[k][j]])</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i],</span><br><span class="line">                    dp[i - w[t[k][j]]] + c[t[k][j]]);  <span class="comment">// 像0-1背包一样状态转移</span></span><br></pre></td></tr></table></figure>
<h3 id="方案数问题">7. 方案数问题</h3>
<p>对于给定的一个背包容量、物品费用、其他关系等的问题，求装到一定容量的方案总数。</p>
<p>这个时候，我们用<span class="math inline">\(dp_i\)</span>表示装到i时的方案数，然后把状态转移方程由最大值改成求和即可。有：<span class="math inline">\(dp_i=\sum(dp_i,dp_{i-ci})\)</span></p>
<h6 id="e.g.4-p5664-csp-s2019-emiya家今天的饭-1">e.g.4 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5664">P5664 [CSP-S2019] Emiya家今天的饭</a></h6>
<h3 id="最优方案记录">8. 最优方案记录</h3>
<h4 id="背包的最优方案数">背包的最优方案数</h4>
<h4 id="背包的第k优解">背包的第k优解</h4>
<h3 id="有依赖的背包问题">9. 有依赖的背包问题</h3>
<p>其实从解决一系列背包问题的过程中就可以看出来，做dp的过程是一个不断优化的过程，推出一个初步答案有时候不难，但是想要得到最优复杂度则是一件需要更多思考的工作。</p>
<h2 id="dag上的dp问题">DAG上的dp问题</h2>
<p>一些实际问题中的二元关系可以用DAG来建模，从而将DAG转化为DAG上的最长路/最短路问题。</p>
<h2 id="区间dp">区间dp</h2>
<p>区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过合并小区间的最优解进而得出整个大区间上最优解的dp算法。</p>
<h6 id="e.g.1.-p1880-noi1995石子合并">e.g.1. <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995]石子合并</a></h6>
<p>题目包含了相邻的两个石子堆的合并操作，每次合并可以得到新的石子的和的得分，求你可以得到的最大得分。</p>
<p>我们令<code>f[i][j]</code>表示区间<span class="math inline">\([i,j]\)</span>内的所有石子合并到一起的最大得分。易得转移方程：<span class="math inline">\(f[i][j]=\max\{f[i][k]+f[k+1][j]+\sum_{t=i}^ja_t\}~(i \le k \le j)\)</span>，也就是说当前所求长度的最大值是两个子区间合并的得分加上当前区间合并形成的得分，显然第三项这个求和可以使用前缀和处理。</p>
<p>因为<span class="math inline">\([i,k]\)</span>和<span class="math inline">\([k+1,j]\)</span> 的长度一定比<span class="math inline">\([i,j]\)</span>的区间短，所以状态是从短的区间转移到长的区间 ，所以从短的递推至长的区间即可。</p>
<p>如何处理环呢？ 我们可以把环展开成一个2n长度的链，其中<code>a[i] = a[i+n]</code>，我们就能涵盖可能出现的所有情况。</p>
<p>区间dp的时间复杂度一般是<span class="math inline">\(O(n^3)\)</span>的。递推处代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> j = len+i<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j <span class="keyword">and</span> k&lt;=<span class="number">2</span>*n<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="comment">//第二个区间是[k+1,j]，所以取k不取i，且k是有可能出界的</span></span><br><span class="line">			f[i][j] = <span class="built_in">max</span>(f[i][j],f[i][k]+[k+<span class="number">1</span>][j]+(sum[j]-sum[i<span class="number">-1</span>]))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>每一个<code>f[i][i]</code>的初始值<strong>应为0，因为自己和自己合并没有意义</strong></li>
<li><strong>答案应为<span class="math inline">\(\max\{f[i][n],f[i+1][n+1],\dots ,f[n-1][2n-2]\}\)</span>，而不能仅仅考虑<code>f[i][j]</code>！</strong></li>
<li>初始化数组的时候，<strong>一定别忘了初始化<span class="math inline">\([n+1,2n]\)</span></strong>区间的内容！！</li>
</ul>
<p>附上AC代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">505</span>;</span><br><span class="line"><span class="type">int</span> pre[M],num[M],f[M][M],p[M][M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;num[i];</span><br><span class="line">        num[i+n] = num[i];</span><br><span class="line">        p[i][i] = p[i+n][i+n] =  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">        pre[i] = pre[i<span class="number">-1</span>]+num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=n;len++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> j = i+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]+(pre[j]-pre[i<span class="number">-1</span>]));</span><br><span class="line">                p[i][j] = <span class="built_in">min</span>(p[i][j],p[i][k]+p[k+<span class="number">1</span>][j]+(pre[j]-pre[i<span class="number">-1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans1 = <span class="number">0x3f3f3f3f</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans1 = <span class="built_in">min</span>(ans1,p[i][i+n<span class="number">-1</span>]);</span><br><span class="line">        ans2 = <span class="built_in">max</span>(ans2,f[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;ans2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="e.g.-p1063noip2006提高-能量项链">e.g. <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1063">[P1063][NOIP2006提高] 能量项链</a></h6>
<p>这个题和石子合并十分类似，不过合并公式要稍微改一下。题目中两个区间合并的分数是由两个珠子的两端的值乘上一项中间的值（两个珠子的这个值是相同的），所以当我们合并<span class="math inline">\([l,k]\)</span>和<span class="math inline">\([k+1,r]\)</span>的时候，需要加上l的头*k+1的头*r的尾。注意每个珠子的标号只会合并，不会改变，这也是为什么区间dp是可行的。至于存储，则可以使用<code>pair&lt;int,int&gt;</code>。</p>
<p>附上AC代码，和P1880基本没啥大区别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> f[M][M],a[M];</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;p[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        p[i].first = a[i];</span><br><span class="line">        p[i].second = i==n?a[<span class="number">1</span>]:a[i+<span class="number">1</span>];</span><br><span class="line">        p[i+n] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l+i<span class="number">-1</span>&lt;=n*<span class="number">2</span>;l++)&#123;</span><br><span class="line">            <span class="type">int</span> r = l+i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)&#123;</span><br><span class="line">                f[l][r] = <span class="built_in">max</span>(f[l][r],f[l][k]+f[k+<span class="number">1</span>][r]+p[l].first*p[k+<span class="number">1</span>].first*p[r].second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,f[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树形dp">树形dp</h2>
<p>树形 DP，即在树上进行的 DP。由于树固有的递归性质，树形 DP 一般都是递归进行的。</p>
<h3 id="基本思路">基本思路</h3>
<h6 id="e.g.p1352没有上司的舞会">e.g.<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1352">[P1352]没有上司的舞会</a></h6>
<p>又是一道答案最大化的题目。</p>
<p>我们设<span class="math inline">\(f(i,0/1)\)</span>来补充以i为根的子树中的最优解（最大答案），其中第二维的0和1分别指i不参与和参与舞会的情形。注意只有直属上司才会存在影响。</p>
<p>接下来考虑转移：</p>
<p>我们设<span class="math inline">\(f[x][0]\)</span>表示以x为根的子树在x不参加时的最大快乐值，<span class="math inline">\(f[x][1]\)</span>表示x参加舞会时子树的最大快乐值。设x不来的快乐值为<code>a[x]</code>，有：</p>
<p>如果说x不参加舞会，那么对于x的所有下属n（即子树节点），有<span class="math inline">\(f[x][0] = \sum \max\{f[i][0],f[i][1]\}\)</span> ；</p>
<p>如果x参加舞会，则下属i都不参加，则有<span class="math inline">\(f[x][1] = \sum f[i][0]+a_i\)</span></p>
<p>可以进行dfs，在返回上一层的时候更新当前节点的最优解即可，答案即为<span class="math inline">\(\max(f[root][0],f[root][1])\)</span>。可以发现，一般dp的最终答案和部分答案是局部和整体的关系。</p>
<p>code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">8080</span>;</span><br><span class="line"><span class="comment">//int val[M];</span></span><br><span class="line"><span class="type">int</span> head[M],nxt[M],cnt,to[M];</span><br><span class="line"><span class="type">int</span> dp[M][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> in[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> f,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	to[++cnt] = t;</span><br><span class="line">	nxt[cnt] = head[f];</span><br><span class="line">	head[f] = cnt;</span><br><span class="line">	in[t]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> from)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=nxt[i])&#123;</span><br><span class="line">		<span class="type">int</span> tt = to[i];</span><br><span class="line">		<span class="keyword">if</span>(tt==from)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(tt,now);</span><br><span class="line">		dp[now][<span class="number">1</span>] += dp[tt][<span class="number">0</span>];</span><br><span class="line">		dp[now][<span class="number">0</span>] += <span class="built_in">max</span>(dp[tt][<span class="number">1</span>],dp[tt][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;dp[i][<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> f,t;</span><br><span class="line">		cin&gt;&gt;f&gt;&gt;t;</span><br><span class="line">		<span class="built_in">add</span>(t,f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(in[i]==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">			root = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">max</span>(dp[root][<span class="number">1</span>],dp[root][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树上背包">树上背包</h3>
<p>所谓树上背包，就是有依赖的dp问题。这种dp的特点是，只有树上的依赖关系满足时，才能够选择特定的背包。</p>
<h3 id="换根dp">换根dp</h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://rockeyleo.github.io">rockeyleo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://rockeyleo.github.io/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%977-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">https://rockeyleo.github.io/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%977-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/">学习手记</a><a class="post-meta__tags" href="/tags/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%97/">csp-noip备战日志</a><a class="post-meta__tags" href="/tags/OI/">OI</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%978-%E6%95%B0%E5%AD%A6/" title="csp-noip备战日志8-数学"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">csp-noip备战日志8-数学</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%976-%E5%9B%BE%E8%AE%BA/" title="csp-noip备战日志6-图论"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">csp-noip备战日志6-图论</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/07/20/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%970-5-CSP-S%E5%88%9D%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/" title="csp-noip备战日志0.5-CSP&#x2F;S初试知识点梳理"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-20</div><div class="title">csp-noip备战日志0.5-CSP&#x2F;S初试知识点梳理</div></div></a></div><div><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%971-%E5%B0%8F%E5%AF%84%E5%B7%A7/" title="csp-noip备战日志1-小寄巧"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">csp-noip备战日志1-小寄巧</div></div></a></div><div><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%973-%E6%90%9C%E7%B4%A2/" title="csp-noip备战日志3-搜索"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">csp-noip备战日志3-搜索</div></div></a></div><div><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%974-%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="csp-noip备战日志4-字符串"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">csp-noip备战日志4-字符串</div></div></a></div><div><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%972-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" title="csp-noip备战日志2-基础算法"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">csp-noip备战日志2-基础算法</div></div></a></div><div><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%975-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="csp-noip备战日志5-数据结构"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">csp-noip备战日志5-数据结构</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/07/22/PFz9shrI5nGAZmx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">rockeyleo</div><div class="author-info__description">胡言乱语集</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/rockeyleo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:rockeyleo@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.</span> <span class="toc-text">七 动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7dp"><span class="toc-number">1.1.</span> <span class="toc-text">线性DP</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.1-%E6%B4%9B%E8%B0%B7p1216-usaco1.5ioi1994%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2-number-triangles"><span class="toc-number">1.1.0.0.0.1.</span> <span class="toc-text">e.g.1 [洛谷P1216] [USACO1.5][IOI1994]数字三角形 Number Triangles</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.2-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97lis"><span class="toc-number">1.1.0.0.0.2.</span> <span class="toc-text">e.g.2 最长上升子序列（LIS）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#e.g.2.1-p1020noip1999-%E6%99%AE%E5%8F%8A%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">e.g.2.1 [P1020][NOIP1999 普及]导弹拦截</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.3-%E6%B4%9B%E8%B0%B7p1439%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97lcs"><span class="toc-number">1.1.0.1.0.1.</span> <span class="toc-text">e.g.3 [洛谷P1439]最长公共子序列（LCS）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.4-p5664-csp-s2019-emiya%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD"><span class="toc-number">1.1.0.1.0.2.</span> <span class="toc-text">e.g.4 P5664 [CSP-S2019] Emiya家今天的饭</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2"><span class="toc-number">1.2.</span> <span class="toc-text">背包九讲</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 01背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">状态的表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">状态转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6oleftn2-right"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">复杂度：\(O\left(n^2 \right)\)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">code:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">优化：滚动数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 完全背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E7%9D%80%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">接着优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E4%B8%8D%E8%83%BD%E9%99%8D%E4%BD%8E%E5%88%B0ovn"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">能不能降低到\(O(VN)\)？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E6%88%90%E4%B8%80%E7%BB%B4"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">压缩成一维？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 多重背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-1"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E7%BB%AD%E4%BC%98%E5%8C%96%E5%91%A2"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">继续优化呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 混合背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.-p1941-noip2014%E6%8F%90%E9%AB%98-%E9%A3%9E%E6%89%AC%E7%9A%84%E5%B0%8F%E9%B8%9F"><span class="toc-number">1.2.4.0.0.1.</span> <span class="toc-text">e.g. P1941 [NOIP2014提高] 飞扬的小鸟</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E8%B4%B9%E7%94%A8%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.5.</span> <span class="toc-text">5. 二维费用的背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.6.</span> <span class="toc-text">6. 分组背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.7.</span> <span class="toc-text">7. 方案数问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.4-p5664-csp-s2019-emiya%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD-1"><span class="toc-number">1.2.7.0.0.1.</span> <span class="toc-text">e.g.4 P5664 [CSP-S2019] Emiya家今天的饭</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E6%96%B9%E6%A1%88%E8%AE%B0%E5%BD%95"><span class="toc-number">1.2.8.</span> <span class="toc-text">8. 最优方案记录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E7%9A%84%E6%9C%80%E4%BC%98%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">背包的最优方案数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E7%9A%84%E7%AC%ACk%E4%BC%98%E8%A7%A3"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">背包的第k优解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BE%9D%E8%B5%96%E7%9A%84%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.9.</span> <span class="toc-text">9. 有依赖的背包问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dag%E4%B8%8A%E7%9A%84dp%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">DAG上的dp问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4dp"><span class="toc-number">1.4.</span> <span class="toc-text">区间dp</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.1.-p1880-noi1995%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6"><span class="toc-number">1.4.0.0.0.1.</span> <span class="toc-text">e.g.1. P1880 [NOI1995]石子合并</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.-p1063noip2006%E6%8F%90%E9%AB%98-%E8%83%BD%E9%87%8F%E9%A1%B9%E9%93%BE"><span class="toc-number">1.4.0.0.0.2.</span> <span class="toc-text">e.g. [P1063][NOIP2006提高] 能量项链</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2dp"><span class="toc-number">1.5.</span> <span class="toc-text">树形dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">1.5.1.</span> <span class="toc-text">基本思路</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.p1352%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A"><span class="toc-number">1.5.1.0.0.1.</span> <span class="toc-text">e.g.[P1352]没有上司的舞会</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85"><span class="toc-number">1.5.2.</span> <span class="toc-text">树上背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%A2%E6%A0%B9dp"><span class="toc-number">1.5.3.</span> <span class="toc-text">换根dp</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/MIT-Missing-Semester%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MIT-Missing-Semester学习笔记"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MIT-Missing-Semester学习笔记"/></a><div class="content"><a class="title" href="/2023/07/24/MIT-Missing-Semester%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MIT-Missing-Semester学习笔记">MIT-Missing-Semester学习笔记</a><time datetime="2023-07-24T14:15:07.000Z" title="Created 2023-07-24 22:15:07">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%979-%E6%9D%82%E9%A1%B9/" title="csp-noip备战日志9-杂项"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="csp-noip备战日志9-杂项"/></a><div class="content"><a class="title" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%979-%E6%9D%82%E9%A1%B9/" title="csp-noip备战日志9-杂项">csp-noip备战日志9-杂项</a><time datetime="2023-07-21T13:26:50.000Z" title="Created 2023-07-21 21:26:50">2023-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%978-%E6%95%B0%E5%AD%A6/" title="csp-noip备战日志8-数学"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="csp-noip备战日志8-数学"/></a><div class="content"><a class="title" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%978-%E6%95%B0%E5%AD%A6/" title="csp-noip备战日志8-数学">csp-noip备战日志8-数学</a><time datetime="2023-07-21T13:26:35.000Z" title="Created 2023-07-21 21:26:35">2023-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%977-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="csp-noip备战日志7-动态规划"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="csp-noip备战日志7-动态规划"/></a><div class="content"><a class="title" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%977-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="csp-noip备战日志7-动态规划">csp-noip备战日志7-动态规划</a><time datetime="2023-07-21T13:26:23.000Z" title="Created 2023-07-21 21:26:23">2023-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%976-%E5%9B%BE%E8%AE%BA/" title="csp-noip备战日志6-图论"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="csp-noip备战日志6-图论"/></a><div class="content"><a class="title" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%976-%E5%9B%BE%E8%AE%BA/" title="csp-noip备战日志6-图论">csp-noip备战日志6-图论</a><time datetime="2023-07-21T13:25:55.000Z" title="Created 2023-07-21 21:25:55">2023-07-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By rockeyleo</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '66861e99fcf865283026',
      clientSecret: '8771be818c9e77873da42d2073ecdddab5c8ed92',
      repo: 'rockeyleo.github.io',
      owner: 'rockeyleo',
      admin: ['rockeyleo'],
      id: '3148ad911d59e9d304664cd413e425bf',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>