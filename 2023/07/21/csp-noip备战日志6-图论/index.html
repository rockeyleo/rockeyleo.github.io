<!DOCTYPE html><html lang="zh_CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>csp-noip备战日志6-图论 | 溢光亭</title><meta name="author" content="rockeyleo"><meta name="copyright" content="rockeyleo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="六 图论 拓扑排序 1. 概念 对于一个有向图，如果一个序列中所有的点都满足前一个点向后一个点有连边（且为前指向后），那这就是一个拓扑序列 不是所有的图都存在拓扑序列，可以进行拓扑排序的图成为拓扑图，拓扑图 &#x3D; 有向无环图。拓扑排序就是求一个DAG的拓扑序列的过程。 DAG至少存在一个入度为0的点，且一个DAG的拓扑序不一定是唯一的。 2. 实现 类似于一个BFS，利用队列：  把所有入度为0的点">
<meta property="og:type" content="article">
<meta property="og:title" content="csp-noip备战日志6-图论">
<meta property="og:url" content="https://rockeyleo.github.io/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%976-%E5%9B%BE%E8%AE%BA/index.html">
<meta property="og:site_name" content="溢光亭">
<meta property="og:description" content="六 图论 拓扑排序 1. 概念 对于一个有向图，如果一个序列中所有的点都满足前一个点向后一个点有连边（且为前指向后），那这就是一个拓扑序列 不是所有的图都存在拓扑序列，可以进行拓扑排序的图成为拓扑图，拓扑图 &#x3D; 有向无环图。拓扑排序就是求一个DAG的拓扑序列的过程。 DAG至少存在一个入度为0的点，且一个DAG的拓扑序不一定是唯一的。 2. 实现 类似于一个BFS，利用队列：  把所有入度为0的点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-07-21T13:25:55.000Z">
<meta property="article:modified_time" content="2023-08-20T05:45:14.001Z">
<meta property="article:author" content="rockeyleo">
<meta property="article:tag" content="学习手记">
<meta property="article:tag" content="csp-noip备战日志">
<meta property="article:tag" content="OI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://rockeyleo.github.io/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%976-%E5%9B%BE%E8%AE%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'csp-noip备战日志6-图论',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-20 13:45:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/my.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/07/22/PFz9shrI5nGAZmx.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="溢光亭"><span class="site-name">溢光亭</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">csp-noip备战日志6-图论</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-07-21T13:25:55.000Z" title="Created 2023-07-21 21:25:55">2023-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-20T05:45:14.001Z" title="Updated 2023-08-20 13:45:14">2023-08-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="csp-noip备战日志6-图论"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="六-图论">六 图论</h1>
<h2 id="拓扑排序">拓扑排序</h2>
<h3 id="概念">1. 概念</h3>
<p>对于一个<strong>有向图</strong>，如果一个序列中所有的点都满足前一个点向后一个点有连边（且为前指向后），那这就是一个拓扑序列</p>
<p>不是所有的图都存在拓扑序列，可以进行拓扑排序的图成为拓扑图，拓扑图 = 有向无环图。拓扑排序就是求一个DAG的拓扑序列的过程。</p>
<p>DAG至少存在一个入度为0的点，且一个DAG的拓扑序不一定是唯一的。</p>
<h3 id="实现">2. 实现</h3>
<p>类似于一个BFS，利用队列：</p>
<ol type="1">
<li>把所有入度为0的点入队；</li>
<li>取出队头t，枚举其所有出边t-&gt;j</li>
<li>对于每一条枚举出的边t-&gt;j，一旦枚举出，就将其删除。删除这条边以后，可以使j的入度-1。</li>
<li>当j的入度变为0时，说明j前面的点已经排序完毕，将j入队</li>
<li>这样操作之后，如果队列中的元素=图的点数，说明拓扑排序好了，否则则说明图没有拓扑序。</li>
<li>如果存在拓扑序，那么拓扑序就是此时队列出队的序列。</li>
</ol>
<p>code（STL队列+链式前向星）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> to[M];</span><br><span class="line"><span class="type">int</span> nxt[M];</span><br><span class="line"><span class="type">int</span> d[M];        <span class="comment">//d用来存储d的入度</span></span><br><span class="line"><span class="type">int</span> ans[M];</span><br><span class="line"><span class="type">int</span> head[M];</span><br><span class="line"><span class="type">int</span> cnt,cnt2,n,m;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> f,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    to[++cnt] = t;</span><br><span class="line">    nxt[cnt] = head[f];</span><br><span class="line">    head[f] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i]==<span class="number">0</span>)q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> ww = q.<span class="built_in">front</span>();</span><br><span class="line">        ans[++cnt2]=ww;		<span class="comment">//如果手写队列，可以不弹出队头而直接移动指针，可以不写ans数组</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[ww];i;i = nxt[i])&#123;</span><br><span class="line">            <span class="type">int</span> now = to[i];	<span class="comment">//别忘了i是边的编号</span></span><br><span class="line">            d[now]--;</span><br><span class="line">            <span class="keyword">if</span>(d[now]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        d[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="keyword">if</span>(cnt2==n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓扑排序的应用">3. 拓扑排序的应用</h3>
<p>拓扑排序往往可以和其他知识点相结合，如dp和tarjan缩点，因为它们都和DAG天然相关。</p>
<p>相关题目：</p>
<h6 id="p1137-旅行计划"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1137">P1137 旅行计划</a></h6>
<p>每给出一个关系，我们就从西边的城市连一条边到东边的城市。我们用每一个点的点权表示以这个点为重点时最多经过的城市，那么显然入度为0的点的点权为1。 当我们拓扑排序删边的时候，可以用转移前的点权+1来更新转移后的点，之后输出每个点的点权即可。</p>
<p>code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">500000</span>;</span><br><span class="line"><span class="type">int</span> head[M],to[M],nxt[M],cnt;</span><br><span class="line"><span class="type">int</span> in[M],out[M],val[M];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> f,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    to[++cnt] = t;</span><br><span class="line">    nxt[cnt] = head[f];</span><br><span class="line">    head[f] = cnt;</span><br><span class="line">    in[t]++; out[f]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">add</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            val[i] = <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="type">int</span> tt = to[i];</span><br><span class="line">            val[tt] = val[now]+<span class="number">1</span>;</span><br><span class="line">            in[tt]--;</span><br><span class="line">            <span class="keyword">if</span>(in[tt]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(tt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;val[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="p1983-noip2013普及车站分级"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1983">P1983 [NOIP2013普及]车站分级</a></h6>
<p>如果火车经过车站但是没有停下，说明分级必然小于通过的站点，用建边的方式维护这种关系，然后求一个拓扑序就可以了。同时进入队列的点属于同一个分级，只要记录<code>whlie()</code>循环中有入度归零的次数即可。</p>
<p>需要注意的是，建边的数量<strong>可能很大</strong>，前向星数组应该开到1e6以上。另外，<strong>图中可能产生重边，不管就炸了（RE）。</strong></p>
<p>code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="p1038-noip2003提高神经网络"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1038">P1038 [NOIP2003提高]神经网络</a></h6>
<p>题目中每个点的状态是在求和之后再减去阈值。我们在拓扑排序删边的时候先给边指向的节点加上<span class="math inline">\(W_iC_i\)</span>，当一个点的入度归零的时候，就可以给<span class="math inline">\(C_j\)</span>减去阈值了。</p>
<p>code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> head[M],nxt[M],to[M],val[M],cnt;</span><br><span class="line"><span class="type">int</span> u[M],c[M],in[M],out[M];  <span class="comment">//入度和出度</span></span><br><span class="line"><span class="type">int</span> n,p;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> f,<span class="type">int</span> t,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    to[++cnt] = t;</span><br><span class="line">    nxt[cnt] = head[f];</span><br><span class="line">    head[f] = cnt;</span><br><span class="line">    val[cnt] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;P1038_2.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n,p;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;c[i]&gt;&gt;u[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++)&#123;</span><br><span class="line">        <span class="type">int</span> f,t,v;</span><br><span class="line">        cin&gt;&gt;f&gt;&gt;t&gt;&gt;v;</span><br><span class="line">        out[f]++; in[t]++;</span><br><span class="line">        <span class="built_in">add</span>(f,t,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i]==<span class="number">0</span>)q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> now = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[now]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                c[to[i]]+=val[i]*c[now];</span><br><span class="line">            &#125;</span><br><span class="line">            in[to[i]]--;</span><br><span class="line">            <span class="keyword">if</span>(in[to[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">                c[to[i]]-=u[to[i]];</span><br><span class="line">                q.<span class="built_in">push</span>(to[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(out[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=c[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;cout&lt;&lt;<span class="string">&quot;NULL&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(out[i]==<span class="number">0</span> <span class="keyword">and</span> c[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;c[i]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="p7113-noip2020提高排水系统"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P7113">P7113 [NOIP2020提高]排水系统</a></h6>
<p>这个玩意需要写高精度……后面用<code>__int128_t</code>表示</p>
<h6 id="p3008-usaco11janroads-and-planes-g"><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3008">P3008 [USACO11JAN]Roads and Planes G</a></h6>
<p><del>首先这个题可以直接用SLF+swap的SPFA水过去，不写swap好像也行</del> <a target="_blank" rel="noopener" href="https://blog.csdn.net/hzf0701/article/details/107694885">spfa优化看这里</a></p>
<p>至于正解，我们不难发现所有的道路都是无向且非负的，所以我们可以考虑把所有的由无向边组成的连通块缩成一个点，之后在这些点之间使用拓朴排序，内部保证为正，则可以使用Dijkstra维护。</p>
<h2 id="欧拉回路">欧拉回路</h2>
<h2 id="最短路">最短路</h2>
<h3 id="传递闭包">传递闭包</h3>
<h3 id="bellman-ford算法">Bellman-Ford算法</h3>
<h4 id="实现-1">实现</h4>
<h4 id="基本ford">基本Ford</h4>
<p><del>略</del></p>
<h5 id="bellman-ford的优化spfa">Bellman-Ford的优化：SPFA</h5>
<p>SPFA是Ford的队列优化版本。与Dijkstra不同的是，SPFA可以求解负权图中的最短路（前提是<strong>没有负环</strong>）需要注意的是，<strong>SPFA算法可以被轻松卡至<span class="math inline">\(O(mn)\)</span>的复杂度，在正权图中不宜使用</strong>。一般来说，存在负权图且确定要使用SPFA的题目不会主动卡SPFA。</p>
<p>code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">500100</span>;</span><br><span class="line"><span class="type">int</span> nxt[M], cnt, dis[M], head[M], to[M], val[M],</span><br><span class="line">s, m, n, num[M], vis[M];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> add = [](<span class="type">int</span> f,<span class="type">int</span> t,<span class="type">int</span> v)&#123;</span><br><span class="line">        to[++cnt] = t;</span><br><span class="line">        nxt[cnt] = head[f];</span><br><span class="line">        head[f] = cnt;</span><br><span class="line">        val[cnt] = v;</span><br><span class="line">    &#125;;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> f,t,v;</span><br><span class="line">        cin&gt;&gt;f&gt;&gt;t&gt;&gt;v;</span><br><span class="line">        <span class="built_in">add</span>(f,t,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            cout&lt;&lt;dis[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.<span class="built_in">push</span>(s); vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> now = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(); vis[now] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[now]; i; i = nxt[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[to[i]] &gt; dis[now]+val[i])&#123;</span><br><span class="line">                dis[to[i]] = dis[now]+val[i];</span><br><span class="line">                <span class="keyword">if</span>(!vis[to[i]])&#123;</span><br><span class="line">                    num[to[i]] = num[now]+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(num[to[i]] &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(to[i]);</span><br><span class="line">                    vis[to[i]] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// q.pop();</span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dijkstra算法">Dijkstra算法</h3>
<h4 id="实现-2">实现</h4>
<p>Dijkstra算法有两种主要形式，对一个n的点，m条边的图求最短路，一种是在每个点时都暴力枚举其它所有的点，此时时间复杂度为<span class="math inline">\(O(m+n^2)\)</span>，也可以使用先队列优化（需要重载运算符），此时复杂度优化为<span class="math inline">\(O((n+m)\log m)\)</span>。</p>
<p>code:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">500100</span>;</span><br><span class="line"><span class="type">int</span> dis[M];</span><br><span class="line"><span class="type">int</span> to[M],head[M],val[M],nxt[M],vis[M],cnt;    <span class="comment">//用于前向星存边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nd</span>&#123;</span><br><span class="line">	<span class="type">int</span> dis,name;    <span class="comment">//表示到点[name]的距离为[dis]</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(nd a,nd b)&#123;<span class="keyword">return</span> a.dis&gt;b.dis;&#125;</span><br><span class="line">	<span class="comment">//注意小根堆重载为大于号</span></span><br><span class="line">&#125;tmp;</span><br><span class="line">priority_queue&lt;nd&gt;pq;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> f,<span class="type">int</span> t,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	val[++cnt] = v;</span><br><span class="line">	nxt[cnt] = head[f];</span><br><span class="line">	head[f] = cnt;</span><br><span class="line">	to[cnt] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> cur = pq.<span class="built_in">top</span>().name; pq.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[cur])<span class="keyword">continue</span>;</span><br><span class="line">		vis[cur]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[cur];i;i=nxt[i])&#123;</span><br><span class="line">			<span class="type">int</span> now = to[i];</span><br><span class="line">			<span class="keyword">if</span>(dis[now]&gt;dis[cur]+val[i])&#123;</span><br><span class="line">				dis[now] = dis[cur]+val[i];</span><br><span class="line">				tmp.name = now; tmp.dis = dis[now];</span><br><span class="line">				pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m,s;    <span class="comment">//s表示起点编号</span></span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> f,t,v;</span><br><span class="line">		cin&gt;&gt;f&gt;&gt;t&gt;&gt;v;</span><br><span class="line">		<span class="built_in">add</span>(f,t,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));    <span class="comment">//用一个最大值来初始化dis数组</span></span><br><span class="line">	dis[s] = <span class="number">0</span>;</span><br><span class="line">	tmp.name = s; tmp.dis = <span class="number">0</span>; pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">	<span class="built_in">dij</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		cout&lt;&lt;dis[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多源最短路">多源最短路</h3>
<h2 id="差分约束">差分约束</h2>
<h2 id="生成树">生成树</h2>
<p>在给定一张无向图，如果在它的子图中，任意两个顶点都是互相连通，并且是一个树结构，那么这棵树叫做<strong>生成树</strong>。当连接顶点之间的图有权重时，权重之和最小的树结构为<strong>最小生成树</strong>。</p>
<p><strong>只有连通图才存在生成树</strong>（非连通图是森林）。也就是说，求最小生成树之前，<strong>还需要判断图是不是联通的！</strong></p>
<h3 id="最小生成树的求解">1. 最小生成树的求解</h3>
<h4 id="prim算法">Prim算法</h4>
<p>Prim的思路和dijkstra有些类似。在用最小边不断松弛的过程中，将选中的边权加入答案即可。</p>
<p>判断连通：我们使用一个计数器统计遍历的点的数量，如果cnt比n小，那么图就是不连通的，也就不存在最小生成树。</p>
<p>与dijkstra一样，pirm算法也可以使用堆来优化。</p>
<p>code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">500100</span>;</span><br><span class="line"><span class="type">int</span> dis[M],vis[M],val[M],to[M],nxt[M],head[M],cnt,ans,tot;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> name,dis;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">friend</span> <span class="keyword">operator</span>&lt;(node a,node b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.dis&gt;b.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tmp;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node&gt;pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tmp.name = <span class="number">1</span>; tmp.dis = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> now = pq.<span class="built_in">top</span>().name; pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[now]==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">        vis[now]=<span class="number">1</span>;</span><br><span class="line">        tot++;</span><br><span class="line">        ans += dis[now];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[now]; i; i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[to[i]]&gt;val[i])&#123;</span><br><span class="line">                dis[to[i]]=val[i];</span><br><span class="line">                tmp.name = to[i]; tmp.dis = dis[to[i]];</span><br><span class="line">                pq.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">auto</span> add = [](<span class="type">int</span> f,<span class="type">int</span> t,<span class="type">int</span> v)&#123;</span><br><span class="line">        nxt[++cnt] = head[f];</span><br><span class="line">        head[f] = cnt;</span><br><span class="line">        to[cnt] = t;</span><br><span class="line">        val[cnt] = v;</span><br><span class="line">    &#125;;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> f,t,v;</span><br><span class="line">        cin&gt;&gt;f&gt;&gt;t&gt;&gt;v;</span><br><span class="line">        <span class="built_in">add</span>(f,t,v);</span><br><span class="line">        <span class="built_in">add</span>(t,f,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">if</span>(tot ==n)&#123;  <span class="comment">//这个地方和Kruskal不一样！！！！这里的total用于记录所有被标记的节点，而Kruskal则是记录边数</span></span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;ans&lt;&lt;endl</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;orz&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="kruskal算法">Kruskal算法</h4>
<p>总的来说，Prim虽然在稠密图乃至完全图复杂度占优，但是实际速度上通常不如kruskal，所以我们更常用Kruskal算法。（<del>这玩意也好写</del>）</p>
<p>Kruskal算法的核心思路是并查集。 把所有的边按照从小到大排序，然后考虑每一条边。如果这一条边能够把两个不同的点集（树）链接在一起，就把这条边加入答案，直到遍历完所有的边。至于判断无解，我们可以统计加入答案的边的个数，因为一棵n个节点的树必然有n-1条边，所以如果<code>cnt!=n-1</code> ，则说明无解。</p>
<p>code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">500100</span>;</span><br><span class="line"><span class="type">int</span> cnt,fa[M],rk[M];</span><br><span class="line"><span class="type">int</span> n,m,ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> f,t,v;</span><br><span class="line">&#125;node[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[a]==a)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span>(fa[a]=<span class="built_in">find</span>(fa[a]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uion</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rk[u]&gt;rk[v])&#123;</span><br><span class="line">        fa[v] = u;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rk[u]==rk[v])&#123;</span><br><span class="line">        fa[v] = u;</span><br><span class="line">        rk[u]++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fa[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Krus</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">find</span>(node[i].f);</span><br><span class="line">        <span class="type">int</span> v = <span class="built_in">find</span>(node[i].t);</span><br><span class="line">        <span class="keyword">if</span>(u==v)&#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="built_in">uion</span>(u,v);  <span class="comment">//事实证明按秩合并在稠密图没啥用(</span></span><br><span class="line">        <span class="comment">// fa[u]=v;</span></span><br><span class="line">        ans += node[i].v;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;n<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> f,t,v;</span><br><span class="line">        cin&gt;&gt;f&gt;&gt;t&gt;&gt;v;</span><br><span class="line">        node[++cnt].f = f;</span><br><span class="line">        node[cnt].t = t;</span><br><span class="line">        node[cnt].v = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(node+<span class="number">1</span>,node+m+<span class="number">1</span>,[](edge a,edge b)&#123;<span class="keyword">return</span> a.v&lt;b.v;&#125;);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Krus</span>()!=n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;orz&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="e.g.-ac1146新的开始">e.g. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/1148/">[AC1146]新的开始</a></h6>
<p>题目的一个比较难以处理的地方是，每一个点都可以选择建立发电站或者连边两种操作，那么只要我们把第一种操作也转化成连边，就好做多了。</p>
<p>处理的方法是把建立发电站的过程转化为向一个超级源点，然后向每一个点连一条权值为在改点建立发电站成本的边，在这n+1个点上求最小生成树即可。</p>
<h4 id="boruvka算法">Boruvka算法</h4>
<p>Boruvka在有些情况也有其用途</p>
<h3 id="次小生成树">2. 次小生成树</h3>
<p>非严格次小生成树：只要边不相同即可，总长可以相等</p>
<p>严格次小生成树：总长严格大于非</p>
<p>基本求法：在一棵最小生成树上，只要连一条新的非树边，再去掉这条非树边连接两点的最小生成树的路径任意一条树边后，得到的还会是一棵生成树。这个过程中一定能得到一棵最小生成树，所以我们需要每一次都去除两点路径之间最小的一条边，来尝试得到次小。这个过程可以使用树上倍增的思路来解决。(注意这题不能Kruskal重构树乱搞)</p>
<h6 id="e.g.-p1480严格次小生成树">e.g. [P1480]严格次小生成树</h6>
<h3 id="kruskal重构树">3. kruskal重构树</h3>
<p>仍然是按照边权从小到大排序后遍历所有边，一次加边会合并两个集合，我们就可以新建一个点，点的点权为新加入边的边权，同时将两个集合的根节点分别设为新建点的左儿子和右儿子，之后我们将两个集合和新建点合并成一个集合，将新建点设为根。 如从<img src="https://img2018.cnblogs.com/blog/1101696/201809/1101696-20180921204338989-1505358819.png" />到<img src="https://img2018.cnblogs.com/blog/1101696/201809/1101696-20180921204418694-1720803955.png" /></p>
<p>在n-1轮之后，我们就得到了一棵恰好有n个叶子节点的二叉树，并且每个非叶子节点都恰好有2个儿子。重构树上的所有叶子节点都是原图上的点，而其它连接它们的节点则是我们新建的。</p>
<p>如： <img src="https://oi-wiki.org/graph/images/mst5.png" /> 它的kruskal重构树是这样的： <img src="https://oi-wiki.org/graph/images/mst6.png" /></p>
<p>kruskal重构树的性质：</p>
<ol type="1">
<li>生成树有2n-1个节点<br />
</li>
<li>重构树是一个大根堆</li>
<li>若将边从大到小排序，则<strong>任意两个点的LCA的点权是两个点的所有路径中最大边权最小的那条路径的边权最大值</strong>，降序则是所有路径中最大的最小边权。</li>
<li><strong>保留边权小于等于 x 的边形成的树</strong>可以转化为<strong>求重构树上点权小于等于x的点的子树</strong>。</li>
</ol>
<h6 id="e.g.p1967noip2013提高-货车运输">e.g.<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1967">[P1967][NOIP2013提高] 货车运输</a></h6>
<p>这个题有生成树+LCA的做法，也可以使用kruskal重构树来解决。显然我们需要维护的就是路径上最大的最小权值，直接重构+LCA即可。</p>
<p>code：（dfs有点小锅，注意生成的可能是森林 ）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">500100</span>;</span><br><span class="line"><span class="type">int</span> nxt[M],head[M],to[M],cnt;</span><br><span class="line"><span class="type">int</span> fa[M],val[M],vis[M],tot;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; root; <span class="type">int</span> f[M][<span class="number">25</span>], dep[M];</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> f,t,v;</span><br><span class="line">&#125;node[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> f,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    to[++cnt] = t;</span><br><span class="line">    nxt[cnt] = head[f];</span><br><span class="line">    head[f] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[a]==a)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span>(fa[a] = <span class="built_in">find</span>(fa[a]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">krus</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(node+<span class="number">1</span>,node+<span class="number">1</span>+m,[](edge a,edge b)&#123;<span class="keyword">return</span> a.v&gt;b.v;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    tot = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">find</span>(node[i].f), b = <span class="built_in">find</span>(node[i].t);</span><br><span class="line">        <span class="keyword">if</span>(a!=b)&#123;</span><br><span class="line">            val[++tot] = node[i].v; </span><br><span class="line">            <span class="comment">//tot就是新建的点的编号，所以需要初始化成n</span></span><br><span class="line">            fa[a] = fa[b] = fa[tot] = tot;  </span><br><span class="line">            <span class="comment">//注意cnt这个新建点还没有初始化</span></span><br><span class="line">            <span class="built_in">add</span>(a,tot); <span class="built_in">add</span>(tot,a);  </span><br><span class="line">            <span class="comment">//新出现的边是无权的</span></span><br><span class="line">            <span class="built_in">add</span>(b,tot); <span class="built_in">add</span>(tot,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> from=<span class="number">0</span>)</span><span class="comment">//预处理lca</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> ct=head[x];ct;ct=nxt[ct])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(to[ct]==from)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> y=to[ct];</span><br><span class="line">        f[y][<span class="number">0</span>]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">15</span>;++i)</span><br><span class="line">            f[y][i]=f[f[y][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        dep[y]=dep[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[a]&lt;dep[b])<span class="built_in">swap</span>(a,b);   <span class="comment">//保证a&gt;=b</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">15</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[f[a][i]]&gt;=dep[b])a = f[a][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a==b)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">15</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[a][i]!=f[b][i] <span class="keyword">and</span> f[a][i]!=<span class="number">0</span> <span class="keyword">and</span> f[b][i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            a = f[a][i];</span><br><span class="line">            b = f[b][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;P1967_3.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;P1967_3.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> f,t,v;</span><br><span class="line">        cin&gt;&gt;f&gt;&gt;t&gt;&gt;v;</span><br><span class="line">        node[i].f = f;</span><br><span class="line">        node[i].t = t;</span><br><span class="line">        node[i].v = v;  <span class="comment">//边是双向边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">krus</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=tot;i&gt;n;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> f,t;</span><br><span class="line">        cin&gt;&gt;f&gt;&gt;t;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(f)!=<span class="built_in">find</span>(t))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;val[<span class="built_in">lca</span>(f,t)]&lt;&lt;endl;  <span class="comment">//LCA是在重构树上跑的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="连通性问题">连通性问题</h2>
<h3 id="联通分量与强连通分量">1. 联通分量与强连通分量</h3>
<h4 id="定义">定义</h4>
<p>对于一个无向图，如果任意两个点之间是连通的，那么它是连通的。</p>
<p>如果<strong>有向图</strong>的任意两个点之间是连通的，那么称G是一个强连通图。</p>
<p>有向图的极大（极大指的是可能的最大的子图）强连通子图就是这个图的<strong>强联通分量</strong>(SCC)。</p>
<p>注：一个点也是一个SCC</p>
<h4 id="求强连通分量tarjan算法">求强连通分量：Tarjan算法</h4>
<p><a target="_blank" rel="noopener" href="https://lampese.com/2022/07/12/%E6%89%B9%E5%88%A4%E4%B8%8E%E6%8C%91%E6%88%98%E2%80%94%E2%80%94%E7%9C%9F%E6%AD%A3%E7%9A%84Tarjan%E7%AE%97%E6%B3%95%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/#more">批判与挑战——真正的Tarjan算法到底是什么-东灯的寒舍</a></p>
<p>比较完备的tarjan详解，包含了多个同名的Tarjan算法</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shadowland/p/5872257.html">Tarjan算法&amp;模板-SHHHS-博客园</a></p>
<blockquote>
<p>Robert E. Tarjan（罗伯特·塔扬，1948~），生于美国加州波莫纳，计算机科学家。Tarjan 发明了很多算法和数据结构。不少他发明的算法都以他的名字命名，以至于有时会让人混淆。比如求各种连通分量的 Tarjan 算法，求 LCA的 Tarjan 算法。并查集、Splay、Toptree 也是 Tarjan 发明的。我们这里要介绍的是在有向图中求强连通分量的 Tarjan 算法。 ——OIwiki</p>
</blockquote>
<h5 id="前置知识dfs生成树">前置知识：dfs生成树</h5>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43848437/article/details/105133155">DFS 树_malanlllll的博客-CSDN</a></p>
<p>假设我们对一张图以任意一个点作为起点进行DFS遍历:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	vis[u] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = head[u];u;u = nxt[u])&#123;      <span class="comment">//假设图已经使用链式前向星存好了</span></span><br><span class="line">		<span class="type">int</span> now = to[i];</span><br><span class="line">		<span class="keyword">if</span>(!vis[now])<span class="built_in">dfs</span>(now);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以用一个动图来感受这一过程：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/2020032707535368.png#pic_center" alt="" /><figcaption>2020032707535368.png (639×669) (csdnimg.cn)</figcaption>
</figure>
<p>我们再以下图为例：</p>
<p><img src="https://oi-wiki.org/graph/images/dfs-tree.svg" /></p>
<p>当我们建立好一棵dfs树之后，就可以把<strong>原图</strong>的所有边分为两类:一类是DFS经过的边，称之为树边（黑色），一类是非树边。</p>
<p>非树边还可分为几类：一种是指向祖先的返祖边（红色），一种是指向子树的前向边（绿色），剩下的指向已经搜索过的其它子树的边则为横叉边（蓝色）（为什么是已经搜索过的边呢？因为如果指向一个未搜索过的边，边会是一条树边）。</p>
<h5 id="tarjan的实现">Tarjan的实现</h5>
<p>我们考虑 DFS 生成树与强连通分量之间的关系。</p>
<p>Tarjan算法中为每一个节点u维护了以下几个变量：</p>
<ol type="1">
<li><span class="math inline">\(dfn_u\)</span>：dfs搜索到u时的次序</li>
<li><span class="math inline">\(low_u\)</span>：从u出发（通过图上的任意边）所能访问到节点的最小dfn，因为从根开始的一条路径上的 dfn 严格递增，low 严格非降，所以<code>low[n]</code>可初始化为<code>dfn[n]</code>。</li>
</ol>
<p>我们需要把每一层dfs的起点u放到一个栈里面。</p>
<ul>
<li>当我们递归搜索u的每个邻接点v的时候，如果这个点还没有被访问，那么这条边会成为一条新的树边（如果说这种边最后没被dfs遍历到，就会变成前向边，没有影响），放心递归搜索。搜索回溯的时候，用<code>min(low[u],low[v])</code>来更新<code>low[u]</code>；</li>
<li>如果邻接点已经被访问过，并且还在栈中，表示当前边是一条横叉边或返祖边，连接的节点的dfn必然不大于u自己，所以可以直接用<code>dfn[v]</code>来更新<code>dfn[u]</code>，即令<code>low[u]=min(low[u],dfn[v])</code>（这个时候的low标记可能是没有处理好的，所以不应当在此时访问，不过应该仍然正确）</li>
<li>如果v被访问过且不在栈中，说明v所在的联通分量已经处理过了，所以不需要操作。<br />
</li>
<li>如果一个点的dfn值=low，那么这个点的下方就构成了一个强连通分量，这个时候栈中的u及在u上方的节点就是一个SCC。同时不难发现，只有一个点的SCC也是可以处理的。</li>
</ul>
<p>Tarjan算法的时间复杂度为<span class="math inline">\(O(n+m)\)</span>。</p>
<p>标准写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	dfn[u] = low[u] = ++tme;</span><br><span class="line">	stk.<span class="built_in">push</span>(u), instk[u] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = head[u];i;i=nxt[i])&#123;</span><br><span class="line">		<span class="type">int</span> tt = to[i];</span><br><span class="line">		<span class="keyword">if</span>(!dfn[tt])&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(tt);</span><br><span class="line">			low[u] = <span class="built_in">min</span>(low[u],low[tt]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(instk[tt])low[u] = <span class="built_in">min</span>(low[u],dfn[tt]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[u] == low[u])&#123;</span><br><span class="line">		scc++;</span><br><span class="line">		<span class="type">int</span> tmp;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			tmp = stk.<span class="built_in">top</span>(); stk.<span class="built_in">pop</span>();</span><br><span class="line">			instk[tmp] = <span class="literal">false</span>;</span><br><span class="line">			id[tmp] = scc;</span><br><span class="line">			Size[scc]++;</span><br><span class="line">		&#125;<span class="keyword">while</span>(tmp!=u);</span><br><span class="line">		<span class="comment">//之所以使用do-while是因为dfn=low的这个点自己也是需要标记的，如果写while就要单独处理这个根（二者循环和判断的先后顺序不一样），非常易错</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求强连通分量kosaraju算法">求强连通分量：Kosaraju算法</h4>
<p>Kosaraju利用两次简单的DFS来实现。</p>
<ul>
<li>第一次DFS，选取每一个顶点作为起点（因为图可能不是强连通的，从一个点出发不一定能遍历到所有边），遍历所有未访问过的节点，并在回溯之前给顶点编号，也就是进行后续遍历；</li>
<li>第二次DFS，对原图的反图（即将所有边反向）以标号最大的顶点作为起点进行DFS。以一个点为起点，第二次DFS能够遍历得到的顶点形成的集合就是一个强联通分量；</li>
<li>对于第二次DFS没有访问过的节点，选取标号最大的，重复进行第二步。</li>
</ul>
<p>通过这样的操作，就能够得到一个图的所有强连通分量。</p>
<p>Kosaraju的时间复杂度为<span class="math inline">\(O(n+m)\)</span>，但是常数高于Tarjan，所以也不如tarjan常用。</p>
<h4 id="对连通性性质应用缩点">对连通性性质应用：缩点</h4>
<p>我们可以我们可以将一张图的每个强连通分量都缩成一个点。然后这张图<strong>一定会变成一个 DAG</strong>，可以进行拓扑排序以及更多其他操作 （其实，<strong>Tarjan后的图本身就是拓扑有序的，所以其实不用显式地拓扑排序</strong>）。缩点之后，我们可以记录每一个点所属的SCC，如果两个点连通且不属于同一个SCC，我们就在新图中将两个SCC相连（这个时候原图就可以清空了），否则则不用连边。</p>
<p>模板：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3387">[P3387] 缩点</a></p>
<p>因为重复经过的点只会计算一次，这就意味着只要经过了一个SCC中的任意一个点，就相当于经过了SCC中的所有点。这样我们就可以把一个SCC缩成一个点，最终得到一个DAG，之后就是一个在DAG上dp的问题了。</p>
<p>我们设<code>dp[i]</code>表示</p>
<h6 id="e.g.2-p2341usaco03fallhaoi2006-受欢迎的牛-g">e.g.2 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2341">[P2341][USACO03FALL/HAOI2006] 受欢迎的牛 G</a></h6>
<p>code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> head[N],nxt[M],to[M],cnt;</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tme;</span><br><span class="line"><span class="type">bool</span> instk[N];</span><br><span class="line"><span class="type">int</span> id[N],scc,Size[N];</span><br><span class="line"><span class="type">int</span> out[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> f,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	to[++cnt] = t;</span><br><span class="line">	nxt[cnt] = head[f];</span><br><span class="line">	head[f] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	dfn[u] = low[u] = ++tme;</span><br><span class="line">	stk.<span class="built_in">push</span>(u), instk[u] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = head[u];i;i=nxt[i])&#123;</span><br><span class="line">		<span class="type">int</span> tt = to[i];</span><br><span class="line">		<span class="keyword">if</span>(!dfn[tt])&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(tt);</span><br><span class="line">			low[u] = <span class="built_in">min</span>(low[u],low[tt]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(instk[tt])low[u] = <span class="built_in">min</span>(low[u],dfn[tt]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[u] == low[u])&#123;</span><br><span class="line">		scc++;</span><br><span class="line">		<span class="type">int</span> tmp;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			tmp = stk.<span class="built_in">top</span>(); stk.<span class="built_in">pop</span>();</span><br><span class="line">			instk[tmp] = <span class="literal">false</span>;</span><br><span class="line">			id[tmp] = scc;</span><br><span class="line">			Size[scc]++;</span><br><span class="line">		&#125;<span class="keyword">while</span>(tmp!=u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> f,t;</span><br><span class="line">		cin&gt;&gt;f&gt;&gt;t;</span><br><span class="line">		<span class="built_in">add</span>(f,t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i])<span class="built_in">tarjan</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=n;now++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = head[now];i;i = nxt[i])&#123;</span><br><span class="line">			<span class="type">int</span> tt = to[i];</span><br><span class="line">			<span class="type">int</span> a = id[now], b = id[tt];</span><br><span class="line">			<span class="keyword">if</span>(a!=b)&#123;</span><br><span class="line">				out[a]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> outcnt = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=scc;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(out[i]==<span class="number">0</span>)&#123;</span><br><span class="line">			outcnt++; ans = Size[i];</span><br><span class="line">			<span class="keyword">if</span>(outcnt&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;0&quot;</span>&lt;&lt;endl;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="割点和割边">2. 割点和割边</h3>
<h4 id="割点">割点</h4>
<h5 id="定义-1">定义</h5>
<p>对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的<strong>割点</strong>（又称割顶）。</p>
<h5 id="求割点">求割点</h5>
<p>求割点的方法，也叫Tarjan算法。在DFS过程中求出每一个点的dfn和low，如果一个点的low&gt;=dfn，那么该点是一个割点。</p>
<h4 id="割边">割边</h4>
<p>对于一个无向图，如果删掉一条边后图中的连通分量数增加了，则称这条边为桥或者<strong>割边</strong>，又称桥。</p>
<p>求割边的方法和上面的Tarjan极其相似，只要</p>
<h2 id="树上问题">树上问题</h2>
<h3 id="最近公共祖先lca">最近公共祖先（LCA）</h3>
<p>最近公共祖先指的是一棵树上距离两个节点距离最近的公共祖先，也即是两个点的所有公共祖先中离根最远的那个。</p>
<h4 id="lca的性质">LCA的性质</h4>
<ol type="1">
<li>u是v的祖先，当且仅当<span class="math inline">\(\mathrm{LCA}(u,v)=u\)</span>;</li>
<li>如果u不为v的祖先且v不为u的祖先，那么u，v分别处于<span class="math inline">\(\mathrm{LCA}(u,v)\)</span>的两棵不同的子树中</li>
<li>前序遍历中，<span class="math inline">\(\mathrm{LCA}(S)\)</span>出现在S及其子树节点的前面，后序遍历则在后面；</li>
<li><span class="math inline">\(\mathrm{LCA}(A\cup B) = \mathrm{LCA}(\mathrm{LCA}(A),\mathrm{LCA}(B))\)</span></li>
<li><strong>两点的LCA必在树上两点间的最短路上</strong>；</li>
<li>u，v两点间距离<span class="math inline">\(d(u,v)=h(u)+h(v)-2h(\mathrm{LCA}(u,v))\)</span>，其中<span class="math inline">\(h(a)\)</span>表示a到树根的距离。</li>
</ol>
<h4 id="倍增法求解lca">倍增法求解LCA</h4>
<h6 id="模板p3379-最近公共最先lca">模板：<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3379">[P3379] 最近公共最先（LCA）</a></h6>
<p>使用倍增法求解LCA，可以在<span class="math inline">\(O(n\log n)\)</span>（和ST表一样）预处理，一次查询的复杂度为<span class="math inline">\(O(\log n)\)</span>。</p>
<p>可以用链式前向星来存边，注意边显然是双向的；</p>
<p>预处理：用<code>f[i][j]</code>来表示节点i的第<span class="math inline">\(2^j\)</span>级祖先（规定第1级祖先是其父节点），用<code>depth[i]</code>来表示i的深度，从根节点向下直接dfs即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> now=s, <span class="type">int</span> fa=<span class="number">0</span>)</span></span>&#123;    <span class="comment">//now表示当前节点，fa表示其父亲节点</span></span><br><span class="line">	f[now][<span class="number">0</span>] = fa; depth[now]=depth[fa]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=depth[now];i++)&#123;</span><br><span class="line">		f[now][i] = f[f[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=nxt[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(to[i]!=fa)<span class="built_in">init</span>(to[i],now);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议好好理解这一部分dfs。</p>
<p>之后，就可以愉快倍增了。</p>
<p>如果我们需要查询a和b的LCA，首先应当保证两者的深度是相同的，这样才能一起向上跳。我们先保证<span class="math inline">\(\mathrm{dep}_a\ge \mathrm{dep}_b\)</span>（否则就交换两者），之后令a不断上跳直到二者在同一深度。</p>
<p>考虑我们需要怎么用<span class="math inline">\(2^i\)</span> 来拼出k。只要从大到小找i（显然i应当小于<span class="math inline">\(\log_2k\)</span>），初始化n=0，如果<span class="math inline">\(n+2^i\)</span>大于k，说明这个数不应该选，直接令<code>i--</code>，如果不大于k，就令<code>n+=2^(i--)</code>，直到i=0为止。</p>
<p>用这样的思路，考虑如何上跳即可。</p>
<p>code：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(depth[a]&lt;depth[b])<span class="built_in">swap</span>(a,b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">if</span>(depth[f[a][i]]&gt;=depth[b])a = f[a][i]; <span class="comment">//还没到就上跳</span></span><br><span class="line">	<span class="keyword">if</span>(a==b)<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">20</span>;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[a][k]!=f[b][k])&#123;</span><br><span class="line">			a= f[a][k];</span><br><span class="line">			b= f[b][k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="e.g.p1967noip2013提高-货车运输-1">e.g.<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1967">[P1967][NOIP2013提高] 货车运输</a></h6>
<p>先考虑哪些边是不走的，如果说两个点之间已经有了限重更大的通过方法（这个值应当是路径上所有道路限重的最小值 ），那就不再需要限重小的边了。考虑最大生成树，不难发现最大生成树中的连边是必然要考虑的。如果两个点之间的没有直接的树边相连，那就在生成树上求LCA，求两点经过其LCA的路径上的最小限重即可。因为与上面的第5条性质类似，如果想要到达一个点，必然要经过与其相连的树边，所以树边不可能不考虑；而考虑了必然要通过的边，就不要走多余的边以免徒增新的最小限重，所以所经过路径必然要经过LCA。所以我们就得到了本题的思路：Kruskal求最大生成树，之后每一个询问求LCA，顺便统计路径上的最小边权即可。</p>
<p>虽然说这个时候的kruskal并不能得出一个有意义的结果，但是连边的过程是有意义的。算法仍然成功建立了一组最大生成森林。</p>
<p>至于答案统计，我们可以把LCA改成暴力跳，这样就能一点一点统计数据，或者反正max也是可重复贡献的，也可以用类似ST表的思路维护。</p>
<p>至于是否有解，如果我们通过kruskal建立并查集后起点和终点还不在同一个集合内，那说明两个点之间不可能连通，这个时候可以直接得出无解。</p>
<p>这个题还有另外一种解法：kruskal生成树，在那一节有提到。</p>
<h4 id="tarjan算法求lca">Tarjan算法求LCA</h4>
<p>求LCA的Tarjan算法是离线的，但是复杂度是线性的。</p>
<p>TarjanLCA与TarjanSCC有着异曲同工之妙，也是基于dfs的一种做法。</p>
<p>当我们DFS到树的一个分支的叶子结点上时，我们将图上的点分为三种，一种是已经遍历过且回溯过（其子树也搜完了，不在搜索栈中）的点，设其为第一类点；一种是正在搜索分支上的点（目前在搜索栈中且访问过），设为第二类点；一种是没有搜索到的点，这种店不会在当前点的分支上，他会先后变成第二类和第一类点。</p>
<p>那么，当前搜索的点和第一类点的LCA都一定是第二类点。搜索回溯时，我们按照从子节点到父节点的方向，可以把一个第一类点合并到第二类点中，此时当前搜索点和任意第一类点的LCA就是那个合并到的第二类点，可以用并查集来维护。</p>
<p>而对于任意一个第二类点，显然它和当前点的LCA就是第二类点本身，于是就做完了。</p>
<h6 id="e.g.1-ac1171距离">e.g.1 [AC1171]距离</h6>
<p>首先，对于一颗树来说，两个点之间的路径是唯一的。那么对于树上的距离问题<del>（什么货车运输）</del>，不难发现<span class="math inline">\(图上任意两点距离=两点到根节点距离-2\times 根节点到两点LCA距离\)</span>，所以这本质是一道LCA问题。</p>
<p>Tarjan离线做法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="树上差分">树上差分</h4>
<h3 id="树链剖分">2. 树链剖分</h3>
<p>树链剖分用于将树分割成若干条链的形式，以维护树上路径的信息。</p>
<p>树链剖分有多种形式，如重链剖分、长链剖分、用于Link/cut Tree的实链剖分等等。多数情况下，树链剖分指的是重链剖分。</p>
<h4 id="重链剖分">重链剖分</h4>
<p>重链剖分可以将树上的任意一条路径划分为不超过<span class="math inline">\(O(\log n)\)</span> 条连续的链，每条链的深度互不相同。</p>
<p>重链剖分还能保证划分出的每条链上的节点 DFS 序连续，因此可以方便地用一些维护序列的数据结构（如线段树）来维护树上路径的信息。如修改树上两点之间路径上的所有点的值、查询树上两点之间的路径上节点权值的和/最值等信息等等。</p>
<p>对于树上一个节点的所有子节点，我们定义<strong>重子节点</strong>表示其子节点中子树节点数最多的子结点（如有多个子树最大的子结点则取其一，如没有子节点则无重子节点）；而<strong>轻子节点</strong>则表示剩下的所有节点。从当前节点到重子节点的边称为<strong>重边</strong>，到轻子节点的边则是<strong>轻边</strong>，若干条重边就组成了<strong>重链</strong>。 如果我们把单个节点也看做重链，就可以把一棵树分为若干条重链。</p>
<p>如：</p>
<p><img src="https://oi-wiki.org/graph/images/hld.png" /></p>
<h4 id="重链剖分的实现">重链剖分的实现</h4>
<p><del>又是DFS。</del></p>
<p>DFS序见Tarjan算法一节。</p>
<p>树剖的实现需要两个DFS，第一个用于记录父节点、深度、子树大小、重子节点的信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>另一个则用于维护每一条链的头、重边DFS时的DFS序（DFN），以及DFN对应的节点编号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="重链剖分的性质">重链剖分的性质</h4>
<ol type="1">
<li>树上的每一个节点都属于且<strong>仅属于一条重链</strong>，也即重链会将整棵树完全剖分；</li>
<li>重链的头不一定是重子节点；</li>
<li>划分出的每条链上的节点的DFS序连续；</li>
</ol>
<h2 id="二分图">二分图</h2>
<p>如果一个图可以被分为两个集合，且集合内部没有相互的连边，那么称这个图为一个二分图。</p>
<h3 id="二分图的性质">二分图的性质</h3>
<ol type="1">
<li>如果两个集合中的点分别染成黑白两种颜色，那么图的每一条边都会连接两个不同颜色的点</li>
<li>二分图中不存在长度为奇数的环，因为每一条边都是从一个集合走到另一个集合，只有走偶数次才可能回到同一个集合。</li>
</ol>
<h3 id="二分图的判定">二分图的判定</h3>
<p>我们可以使用dfs或bfs来给这张图染色， 如果发现了奇环，则不是二分图，否则则是。也可以使用并查集来做。</p>
<p>DFS做法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式前向星存边</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> c=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	color[now] = c;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = head[now];i;i=nxt[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(color[to[i]]==c)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(!color[to[i]] <span class="keyword">and</span> !<span class="built_in">dfs</span>(to[i],-c))<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//进一步搜索</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> f,t;</span><br><span class="line">		cin&gt;&gt;f&gt;&gt;t;</span><br><span class="line">		<span class="built_in">add</span>(f,t);    <span class="comment">//实现略</span></span><br><span class="line">		<span class="built_in">add</span>(t,f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!color[i])&#123;    <span class="comment">//color默认值为0，两种颜色分别为1和-1</span></span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">dfs</span>(i))&#123;</span><br><span class="line">				cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!flag)cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分图的应用">二分图的应用</h3>
<h4 id="二分图最大匹配">二分图最大匹配</h4>
<p>给定一个二分图G，要求选出一些边，使得这些边没有公共顶点，且边的数量最大。</p>
<h4 id="二分图最大权匹配">二分图最大权匹配</h4>
<h4 id="一般图最大匹配">一般图最大匹配</h4>
<h4 id="一般图最大权匹配">一般图最大权匹配</h4>
<h2 id="网络流">网络流</h2>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://rockeyleo.github.io">rockeyleo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://rockeyleo.github.io/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%976-%E5%9B%BE%E8%AE%BA/">https://rockeyleo.github.io/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%976-%E5%9B%BE%E8%AE%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E6%89%8B%E8%AE%B0/">学习手记</a><a class="post-meta__tags" href="/tags/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%97/">csp-noip备战日志</a><a class="post-meta__tags" href="/tags/OI/">OI</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%977-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="csp-noip备战日志7-动态规划"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">csp-noip备战日志7-动态规划</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%975-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="csp-noip备战日志5-数据结构"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">csp-noip备战日志5-数据结构</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/07/20/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%970-5-CSP-S%E5%88%9D%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/" title="csp-noip备战日志0.5-CSP&#x2F;S初试知识点梳理"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-20</div><div class="title">csp-noip备战日志0.5-CSP&#x2F;S初试知识点梳理</div></div></a></div><div><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%971-%E5%B0%8F%E5%AF%84%E5%B7%A7/" title="csp-noip备战日志1-小寄巧"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">csp-noip备战日志1-小寄巧</div></div></a></div><div><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%973-%E6%90%9C%E7%B4%A2/" title="csp-noip备战日志3-搜索"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">csp-noip备战日志3-搜索</div></div></a></div><div><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%974-%E5%AD%97%E7%AC%A6%E4%B8%B2/" title="csp-noip备战日志4-字符串"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">csp-noip备战日志4-字符串</div></div></a></div><div><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%972-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" title="csp-noip备战日志2-基础算法"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">csp-noip备战日志2-基础算法</div></div></a></div><div><a href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%975-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="csp-noip备战日志5-数据结构"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-21</div><div class="title">csp-noip备战日志5-数据结构</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/07/22/PFz9shrI5nGAZmx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">rockeyleo</div><div class="author-info__description">胡言乱语集</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/rockeyleo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:rockeyleo@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-%E5%9B%BE%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">六 图论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. 拓扑排序的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#p1137-%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">1.1.3.0.0.1.</span> <span class="toc-text">P1137 旅行计划</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#p1983-noip2013%E6%99%AE%E5%8F%8A%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7"><span class="toc-number">1.1.3.0.0.2.</span> <span class="toc-text">P1983 [NOIP2013普及]车站分级</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#p1038-noip2003%E6%8F%90%E9%AB%98%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">1.1.3.0.0.3.</span> <span class="toc-text">P1038 [NOIP2003提高]神经网络</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#p7113-noip2020%E6%8F%90%E9%AB%98%E6%8E%92%E6%B0%B4%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.3.0.0.4.</span> <span class="toc-text">P7113 [NOIP2020提高]排水系统</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#p3008-usaco11janroads-and-planes-g"><span class="toc-number">1.1.3.0.0.5.</span> <span class="toc-text">P3008 [USACO11JAN]Roads and Planes G</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF"><span class="toc-number">1.2.</span> <span class="toc-text">欧拉回路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.3.</span> <span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85"><span class="toc-number">1.3.1.</span> <span class="toc-text">传递闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bellman-ford%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">Bellman-Ford算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%ACford"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">基本Ford</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#bellman-ford%E7%9A%84%E4%BC%98%E5%8C%96spfa"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">Bellman-Ford的优化：SPFA</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">Dijkstra算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.3.4.</span> <span class="toc-text">多源最短路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.4.</span> <span class="toc-text">差分约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%B1%82%E8%A7%A3"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. 最小生成树的求解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#prim%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">Prim算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">Kruskal算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.-ac1146%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B"><span class="toc-number">1.5.1.2.0.1.</span> <span class="toc-text">e.g. [AC1146]新的开始</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#boruvka%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">Boruvka算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. 次小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.-p1480%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.5.2.0.0.1.</span> <span class="toc-text">e.g. [P1480]严格次小生成树</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kruskal%E9%87%8D%E6%9E%84%E6%A0%91"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. kruskal重构树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.p1967noip2013%E6%8F%90%E9%AB%98-%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93"><span class="toc-number">1.5.3.0.0.1.</span> <span class="toc-text">e.g.[P1967][NOIP2013提高] 货车运输</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E9%80%9A%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">连通性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E9%80%9A%E5%88%86%E9%87%8F%E4%B8%8E%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 联通分量与强连通分量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8Ftarjan%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">求强连通分量：Tarjan算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86dfs%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.6.1.2.1.</span> <span class="toc-text">前置知识：dfs生成树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tarjan%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.1.2.2.</span> <span class="toc-text">Tarjan的实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8Fkosaraju%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">求强连通分量：Kosaraju算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%BF%9E%E9%80%9A%E6%80%A7%E6%80%A7%E8%B4%A8%E5%BA%94%E7%94%A8%E7%BC%A9%E7%82%B9"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">对连通性性质应用：缩点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.2-p2341usaco03fallhaoi2006-%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E7%89%9B-g"><span class="toc-number">1.6.1.4.0.1.</span> <span class="toc-text">e.g.2 [P2341][USACO03FALL&#x2F;HAOI2006] 受欢迎的牛 G</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%B2%E7%82%B9%E5%92%8C%E5%89%B2%E8%BE%B9"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. 割点和割边</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%B2%E7%82%B9"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">割点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">1.6.2.1.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E5%89%B2%E7%82%B9"><span class="toc-number">1.6.2.1.2.</span> <span class="toc-text">求割点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%B2%E8%BE%B9"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">割边</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.</span> <span class="toc-text">树上问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88lca"><span class="toc-number">1.7.1.</span> <span class="toc-text">最近公共祖先（LCA）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lca%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">LCA的性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%8D%E5%A2%9E%E6%B3%95%E6%B1%82%E8%A7%A3lca"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">倍增法求解LCA</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BFp3379-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E6%9C%80%E5%85%88lca"><span class="toc-number">1.7.1.2.0.1.</span> <span class="toc-text">模板：[P3379] 最近公共最先（LCA）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.p1967noip2013%E6%8F%90%E9%AB%98-%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93-1"><span class="toc-number">1.7.1.2.0.2.</span> <span class="toc-text">e.g.[P1967][NOIP2013提高] 货车运输</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tarjan%E7%AE%97%E6%B3%95%E6%B1%82lca"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">Tarjan算法求LCA</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#e.g.1-ac1171%E8%B7%9D%E7%A6%BB"><span class="toc-number">1.7.1.3.0.1.</span> <span class="toc-text">e.g.1 [AC1171]距离</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">树上差分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. 树链剖分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">重链剖分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">重链剖分的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">重链剖分的性质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">1.8.</span> <span class="toc-text">二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.8.1.</span> <span class="toc-text">二分图的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="toc-number">1.8.2.</span> <span class="toc-text">二分图的判定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.3.</span> <span class="toc-text">二分图的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">二分图最大匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%9D%83%E5%8C%B9%E9%85%8D"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">二分图最大权匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">一般图最大匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%9D%83%E5%8C%B9%E9%85%8D"><span class="toc-number">1.8.3.4.</span> <span class="toc-text">一般图最大权匹配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="toc-number">1.9.</span> <span class="toc-text">网络流</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/20/%E6%96%87%E6%98%8E%E4%B9%8B%E4%B8%8B%E7%9A%84%E5%B1%A0%E5%88%80%EF%BC%9A%E6%9C%89%E5%85%B3%E5%BA%9F%E9%99%A4%E6%AD%BB%E5%88%91%E7%9A%84%E8%AE%A8%E8%AE%BA%E5%92%8C%E6%80%9D%E8%80%83/" title="文明之下的屠刀：有关废除死刑的讨论和思考"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文明之下的屠刀：有关废除死刑的讨论和思考"/></a><div class="content"><a class="title" href="/2023/08/20/%E6%96%87%E6%98%8E%E4%B9%8B%E4%B8%8B%E7%9A%84%E5%B1%A0%E5%88%80%EF%BC%9A%E6%9C%89%E5%85%B3%E5%BA%9F%E9%99%A4%E6%AD%BB%E5%88%91%E7%9A%84%E8%AE%A8%E8%AE%BA%E5%92%8C%E6%80%9D%E8%80%83/" title="文明之下的屠刀：有关废除死刑的讨论和思考">文明之下的屠刀：有关废除死刑的讨论和思考</a><time datetime="2023-08-20T05:50:26.000Z" title="Created 2023-08-20 13:50:26">2023-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/MIT-Missing-Semester%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MIT-Missing-Semester学习笔记"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MIT-Missing-Semester学习笔记"/></a><div class="content"><a class="title" href="/2023/07/24/MIT-Missing-Semester%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MIT-Missing-Semester学习笔记">MIT-Missing-Semester学习笔记</a><time datetime="2023-07-24T14:15:07.000Z" title="Created 2023-07-24 22:15:07">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%979-%E6%9D%82%E9%A1%B9/" title="csp-noip备战日志9-杂项"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="csp-noip备战日志9-杂项"/></a><div class="content"><a class="title" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%979-%E6%9D%82%E9%A1%B9/" title="csp-noip备战日志9-杂项">csp-noip备战日志9-杂项</a><time datetime="2023-07-21T13:26:50.000Z" title="Created 2023-07-21 21:26:50">2023-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%978-%E6%95%B0%E5%AD%A6/" title="csp-noip备战日志8-数学"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="csp-noip备战日志8-数学"/></a><div class="content"><a class="title" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%978-%E6%95%B0%E5%AD%A6/" title="csp-noip备战日志8-数学">csp-noip备战日志8-数学</a><time datetime="2023-07-21T13:26:35.000Z" title="Created 2023-07-21 21:26:35">2023-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%977-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="csp-noip备战日志7-动态规划"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="csp-noip备战日志7-动态规划"/></a><div class="content"><a class="title" href="/2023/07/21/csp-noip%E5%A4%87%E6%88%98%E6%97%A5%E5%BF%977-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="csp-noip备战日志7-动态规划">csp-noip备战日志7-动态规划</a><time datetime="2023-07-21T13:26:23.000Z" title="Created 2023-07-21 21:26:23">2023-07-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By rockeyleo</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '66861e99fcf865283026',
      clientSecret: '8771be818c9e77873da42d2073ecdddab5c8ed92',
      repo: 'rockeyleo.github.io',
      owner: 'rockeyleo',
      admin: ['rockeyleo'],
      id: 'e11fe2a3e75a19a9c1c842bda72fa90b',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>