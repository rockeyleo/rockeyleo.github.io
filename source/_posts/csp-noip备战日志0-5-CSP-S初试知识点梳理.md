---
title: csp-noip备战日志0.5-CSP/S初试知识点梳理
date: 2023-07-20 22:54:25
tags: [csp-noip备战日志,学习手记,OI]
---

### *[本文未完成，绝赞摆烂中]*

# CSP-S 初试知识点梳理

## 一 数制转换

#### K进制转十进制

将原数字的每一位与其位权相乘后相加即可

#### 十进制转K进制

- 整数部分：将原数短除[^1]K，**倒取**余数

- 小数部分：循坏*K并不断取产生的整数部分，**顺取**余数

###### eg.1.  173转二进制

![图片](https://www.runoob.com/wp-content/uploads/2018/11/210-2.png)

[^1]: 此处除法指整数除法（可以认为是去掉了余数）

###### eg.2.  0.125转二进制

$0.125\times 2 = 0.25$ ·········0

$0.25\times 2 = 0.5$ ·············0

$0.5\times2 = 1$ ··················1

故$(0.125)_{10}=(0.001)_{2}$

#### 二进制转八进制、十六进制

以小数点为界，整数部分从右向左，小数部分从左到右，以三位为一组转换为八进制，以四位为一组转换为16进制

###### eg.

$(1,111,010,101,101)_2 = (17255)_8$

$(1,101,110.101,1)_2 = (156.54)_8$ ^2fc7d2

$(1,1110,1010,1101)_2 = (1EAD)_{16}$

$(1,1110,1001.1011,1)_2 = (1E9.B8)_{16}$

## 二 信息编码

#### ASCII码

ASCII码可对英文字母，数字，控制符（如换行符），通用符（如=/+）进行编码。基本ASCII码占一个字节，最高位保持为0，其余位可编码$2^7=128$种字符（对应编码0和127个正数[^2][^3]）。

另外还有一种扩展ASCII码，置于第一个字节之后，最高位为1，表示范围为128-255。

`A`的ASCII编码为$(65)_{10}$，`0`则为$(48)_{10}$。

[^2]: 仔细看好，$(1111111)_2=(127)_{10}=2^7-1，(10000000)_2=(128)_{10}=2^7$
[^3]: ASCII码为0的符号是null，的确存在

#### 中文的编码表示

汉字使用GB码进行编码，一个汉字占两个字节，存储时两个字节最高位均置为1，可表示$2^7 \times 2^7 = 16384$种字符。

中文在输出时，需要通过一种字形码进行点阵绘图。一个16\*16的点阵汉字需要$16 \times 16 \div8=32$个字节来储存。表示顺序为：从上到下，从左到右，8个为一字节。

#### 哈夫曼编码

1. 哈夫曼编码的结构基础是哈夫曼树。

   建树原理：每次取权值最小的两棵子树合并成一棵子树，直到最终所有的元素合并成一棵树。这棵树就是哈夫曼树

   （子树的权值是其叶子结点的权值之和，在哈夫曼编码中，这个权值是字符的出现次数）

![哈夫曼树](https://pic3.zhimg.com/80/v2-48e3cdd3fbd1e25ce40a4205a753e24e_720w.jpg)

2. 哈夫曼编码利用了贪心的思想，总的来说就是将出现多的字符用尽量短的编码来表示。建好树以后，要获取每个字符的哈夫曼编码，就通过根节点遍历到对应的子节点，所经历的路径就是这个字符的编码

![encoded](https://pic4.zhimg.com/80/v2-82b9db088f6babb04754a98f22978433_720w.jpg)

| 字符 | e    | d    | b    | a    | ' '  | c    |
| :--- | ---- | ---- | ---- | ---- | ---- | ---- |
| 编码 | 1110 | 1111 | 110  | 00   | 01   | 10   |

## 三 位运算和布尔运算

#### 原码，反码，补码

1. 机器数和真值

   机器数是数字在计算机中的二进制表示形式，一般最高位表示正负（1表示负，0表示正），故8位二进制数只有7位用于存储数据。

   真值就是去掉最高位符号位后机器存储的真实值。如10000011的真值为3而非131（$(10000011)_2=(131)_{10}$）

2. 原码和反码

   原码指的就是符号位加上真值的绝对值，也就是数字的机器储存形式。

   整数的反码就是其本身，负数的反码是**符号位不变**，其余各个数取反。

   ###### e.g.

   $(-1)_{10} = [1,0000001]_原$ -> $[1,1111110]_反$

3. 补码

   正数的补码还是其本身。

   负数的补码是其反码+1（**会进位，但是新增的位数会被忽略**）

   ###### e.g.

   $(-127)_{10} = [1,1111111]_原$ -> $[1,0000000]_反$ -> $[1,0000001]_补$

   $(-0)_{10} = [1,0000000]_原$ -> $[1,1111111]_反$ -> $[0,0000000]_补$（**我们规定0和-0的补码是一样的**）

   - 注意一点，计算机使用补码存储数据，-0的补码和0的补码一样，也就相当于不存在-0了，而$[10000000]$这个补码没有数字占用。所以我们规定$[10000000]$表示-128（-128的二进制有8位，原本需要9位来表示）。因此，如果有一个占一字节的数组，那么它的实际存储范围会是$[-10000000,1111111]$，即$[-128,127]$。int类型（用4个字节存储）的范围为$[-2^{31},2^{31}-1]$，也是如此。

#### 位运算

1. 常见的位运算主要用与，或，非，异或四种运算。

   将1视为true，0视为false，前三者和普通逻辑运算没有太大差别。

   异或就是找不同，两个值不同时结果为1,相同则为0。

   C++中，使用&表示按位或，|表示按位与，^表示异或。

2. 移位

   C++中的按位操作符只对于数字的最低位进行，所以要配合移位来使用。
   左移运算符会将最左位丢弃，在最右位置补0。因此有：$n<<1=2n$

   右移运算则分为有符号（如在C++中对int类型右移）和无符号（如对unsigned int右移）两种情况；右移的规则和左移类似，位于最高位的符号位不会参与右移。

   因此有：$n>>1=\lfloor n/2 \rfloor$[^4]。

   [^4]: 需要注意的是，在C++中，对负数使用右移运算，答案**向偏小的方向取整**（而整除是向0的方向——也即**绝对值**小的方向——取整），如$-3>>1=-2，-3/2=-1$

#### 布尔运算

在布尔运算里，用$\vee$来表示或，用$\land$表示与，用$\oplus$表示异或，用$\neg$表示取反，规则类似集合运算

在其他场合，可能还会遇到使用a xor b来表示a与b异或的情况。



补充：符号运算顺序一览

![](https://img-blog.csdnimg.cn/9e6d8a9983e5430081e74994eddeafe3.png#pic_center)

## 四 算法及复杂度分析a sd

#### 排序算法

| 算法           | 桶排序 | 基数排序 | 归并排序   | 快速排序   | 堆排序     | 希尔排序                   | 冒泡排序     | 选择排序 | 插入排序     |
| -------------- | ------ | -------- | ---------- | ---------- | ---------- | -------------------------- | ------------ | -------- | ------------ |
| 平均时间复杂度 | $O(n)$ | $O(n)$   | $O(nlogn)$ | $O(nlogn)$ | $O(nlogn)$ | $O(n^{\frac{3}{2}})$（？） | $O(n^2)$[^5] | $O(n^2)$ | $O(n^2)$[^5] |
| 最差时间复杂度 | $O(n)$ | $O(n)$   | $O(nlogn)$ | $O(n^2)$   | $O(nlogn)$ | $O(n^2)$                   | $O(n^2)$     | $O(n^2)$ | $O(n^2)$     |
| 稳定性         | 不稳定 | 稳定     | 稳定       | 不稳定     | 不稳定     | 不稳定                     | 稳定         | 不稳定   | 稳定         |

[^5]: 冒泡排序和插入排序的最佳复杂度可达到$O(n)$

#### 其它常见数据结构的复杂度

![](https://pic1.zhimg.com/v2-05c78d4c4c3e4e5b1303435fc0800238_r.jpg)

## 五 树与图论

#### 树

1. 基本概念

   - 深度：一个节点向上连到根节点的的路径上的边数

   - 树的高：一棵树的深度的最大值

   - 叶节点：没有子节点的节点
   - 节点的度：

2. 二叉树

   - 二叉树的遍历

     前/中/后序遍历都指根节点的遍历先后，除了根节点，先左后右。

   - 完全二叉树

     只有最下面两层结点的度数可以小于 22，且最下面一层的结点都集中在该层的最左侧

     ![](https://oi-wiki.org/graph/images/tree-binary-complete.svg)

   - 满二叉树

     即满的二叉树（

     一颗深度为h的二叉树的节点数$\le2^n-1$，当且仅当是满二叉树时取等

   - 一颗二叉树的叶子结点树一定为度为2的点的个数+1（$n_2=n_0-1$）

   - 具有n个节点的完全二叉树的深度为$[log_2n]+1$

#### 图论

1. 基本概念

   - 图分有向图和无向图两种
   - 与一个顶点相关联的边的条数称为该顶点的度，有向图还分入度和出度
   - 简单图：若一个图中没有自环和重边，它被称为简单图。[^6]
   - 具有至少两个顶点的简单无向图中一定存在度相同的结点。
   - 完全图：图中任意两点均有连边的图。
   - 一个有n个节点的无向完全图中有$\frac{n(n-1)}{2}$条边。
   - 欧拉路和欧拉回路
     - 欧拉路中有且只有两个奇点
     - 欧拉回路中没有奇点


[^6]: 在有向图中，a->b和a<-b不算重边

2. 图的存储

   - 邻接矩阵

     用一个二维数组`j[a][b]`来表示从a到b的连边长（无边设为一个极大值）

     空间复杂度$O(n^2)$，遍历全图复杂度$O(n^2)$，遍历一个点的出边$O(n)$。

   - 邻接表

     简单来说就是用一个链表把一个点指向的所有节点连在一起

     ![](https://www.dotcpp.com/oj/ueditor/php/upload/image/20191211/1576070228570316.png)

     ![](https://www.dotcpp.com/oj/ueditor/php/upload/image/20191211/1576070307448389.png)

     空间复杂度$O(e)$，遍历全图复杂度$O(n+e)$，遍历点$u$的出边$O(d^+(u))$

3. 图的最短路

   - 常用求解方法：Dijkstra

     - 基本原理

       将结点分成两个集合：已确定最短路长度的点集（记为$S$集合）的和未确定最短路长度的点集（记为$T$集合）。一开始所有的点都属于$T$集合。

       初始化$dis(s)=0$，其他点的$dis$均为$+\infty$。

       然后重复这些操作：

       从$T$集合中，选取一个最短路长度最小的结点，移到$S$集合中。
       对那些刚刚被加入$S$集合的结点的所有出边执行松弛操作。
       直到  集合为空，算法结束。

     - 时间复杂度

       - 在无堆优化时，复杂度为$O(n^2+m)$
       - 优先队列优化后，复杂度为$O(mlogm)$

4. 二分图

   - 二分图的一些性质
     - 如果两个集合中的点分别染成黑色和白色，可以发现二分图中的每一条边都一定是连接一个黑色点和一个白色点；
     - 二分图无奇环

   - 二分图判定：DFS/BFS染色

## 六 其它数据结构

#### 栈

1. 前/中/后缀表达式

   - 前缀表达式

     从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算，并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果。

     ###### e.g.

     `- * + 3 4 5 6`

     1. 从右至左扫描，将6、5、4、3压入堆栈；
       2. 遇到 + 运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算 3+4 的值，得7，再将7入栈；
       3. 接下来是 * 运算符，因此弹出7和5，计算 7*5=35 ，将35入栈。
       4. 最后是 - 运算符，计算 35-6 的值，即29，得最终结果29.

   - 后缀表达式

     又称逆波兰表达式，和前缀表达式类似，但是将算符位于操作数之后。

     求值时，从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算。并将结果入栈；重复上述过程直到表达式最右端，最后运算出的值即为表达式的结果。

     ###### e.g.

     `3 4 + 5 * 6 -`

            1. 从左至右扫描，将3和4入栈；
            2. 遇到运算符 + ，因此弹出4和3，计算 3+4 的值，再将7入栈；
            3. 将5入栈；
            4. 接下来是 * 运算符，因此弹出5和7，计算出 7*5=35，将35入栈；
            5. 将6入栈；
            6. 最后是 - 运算符，计算 35-6 的值，即29，由此得出最终结果。

## 七 数学

#### 组合数学

1. 基本公式

   - 排列公式：$P_n^m = A_n^m = n(n-1)(n-2)...(n-m+1) = \frac{n!}{(n-m)!}$

     特别的，$A_n^n=n!$（注意0!=1）

     （为方便计算，也可记为$\prod^m_{i=n}i$）

     ###### e.g.

     $A_7^4=7 \times 6 \times 5 \times 4 = 840$

   - 组合公式：$C_n^m = \frac{A_n^m}{m!} = \frac{n!}{(n-m)!}$

     （为方便计算，也可记为$\frac{\prod^{m}_{i=n}i}{m!}$）

     ###### e.g.

     $C^4_7 = \frac{7 \times 6 \times 5 \times 4}{4 \times 3 \times 2 \times 1} = 35$

2. 计算技巧

   - 特殊情况优先分类

   - 插板法
   - 隔板法

   ~~高中数学学完以后再回来看觉得排列组合有意思的地方真不少，有机会把这一块做成番外~~

   
